// Generated by ProtoGen, Version=2.4.1.555, Culture=neutral, PublicKeyToken=17b3b1f090c3ea48.  DO NOT EDIT!
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace proto_client2access {
  
  
  #region Enums
  public enum Proto_C2ACmd {
    E_C2A_AUTH_SYN = 0,
    E_A2C_AUTH_SYNACK = 1,
    E_C2A_AUTH_ACK = 2,
    E_C2A_TRANSFERDATA = 3,
    E_A2C_TRANSFERDATA = 4,
    E_C2A_KEEPALIVED = 5,
    E_A2C_KEEPALIVED = 6,
    E_A2C_STARTOK = 7,
  }
  
  public enum Proto_C2ACompressType {
    E_NO_COMPRESS = 0,
    E_GZIP = 1,
    E_SNAPPY = 2,
  }
  
  public enum Proto_C2AEncryptType {
    E_NO_ENCRYPT = 0,
    E_AES = 1,
    E_3DES = 2,
  }
  
  #endregion
  
  #region Messages
  public sealed partial class C2A_AuthSyn : pb::GeneratedMessageLite {
    public C2A_AuthSyn() { }
    private static readonly string[] _c2AAuthSynFieldNames = new string[] { "account_info", "dhpubkey_client", "enet_player_uin", "token" };
    private static readonly scg::List<uint> _c2AAuthSynFieldTags = new scg::List<uint> { 18, 10, 32, 26 };
    
    
    public const int dhpubkey_clientFieldNumber = 1;
    private bool hasdhpubkey_client;
    private pb::ByteString dhpubkeyClient_ = pb::ByteString.Empty;
    public bool Hasdhpubkey_client {
      get { return hasdhpubkey_client; }
    }
    public pb::ByteString dhpubkey_client {
      get { return dhpubkeyClient_; }
      set { hasdhpubkey_client = true; dhpubkeyClient_ = value;}
    }
    
    public const int account_infoFieldNumber = 2;
    private bool hasaccount_info;
    private pb::ByteString accountInfo_ = pb::ByteString.Empty;
    public bool Hasaccount_info {
      get { return hasaccount_info; }
    }
    public pb::ByteString account_info {
      get { return accountInfo_; }
      set { hasaccount_info = true; accountInfo_ = value;}
    }
    
    public const int tokenFieldNumber = 3;
    private bool hastoken;
    private string token_ = "";
    public bool Hastoken {
      get { return hastoken; }
    }
    public string token {
      get { return token_; }
      set { hastoken = true; token_ = value;}
    }
    
    public const int enet_player_uinFieldNumber = 4;
    private bool hasenet_player_uin;
    private ulong enetPlayerUin_;
    public bool Hasenet_player_uin {
      get { return hasenet_player_uin; }
    }
    [global::System.CLSCompliant(false)]
    public ulong enet_player_uin {
      get { return enetPlayerUin_; }
      set { hasenet_player_uin = true; enetPlayerUin_ = value;}
    }
    
    public override bool IsInitialized {
      get {
        if (!hasdhpubkey_client)return false;
        if (!hasaccount_info)return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _c2AAuthSynFieldNames;
      if (hasdhpubkey_client) {
        output.WriteBytes(1, field_names[1], dhpubkey_client);
      }
      if (hasaccount_info) {
        output.WriteBytes(2, field_names[0], account_info);
      }
      if (hastoken) {
        output.WriteString(3, field_names[3], token);
      }
      if (hasenet_player_uin) {
        output.WriteUInt64(4, field_names[2], enet_player_uin);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasdhpubkey_client) {
        size += pb::CodedOutputStream.ComputeBytesSize(1, dhpubkey_client);
      }
      if (hasaccount_info) {
        size += pb::CodedOutputStream.ComputeBytesSize(2, account_info);
      }
      if (hastoken) {
        size += pb::CodedOutputStream.ComputeStringSize(3, token);
      }
      if (hasenet_player_uin) {
        size += pb::CodedOutputStream.ComputeUInt64Size(4, enet_player_uin);
      }
      memoizedSerializedSize = size;
      return size;
    }
    public override void Reset(bool recursive = true, bool reuse = false)
    {
      dhpubkeyClient_ = pb::ByteString.Empty;
      hasdhpubkey_client = false;
      accountInfo_ = pb::ByteString.Empty;
      hasaccount_info = false;
      token_ = "";
      hastoken = false;
      enetPlayerUin_ = 0UL;
      hasenet_player_uin = false;
      memoizedSerializedSize = -1;
      base.Reset(recursive, reuse);
    }
    public static Builder CreateBuilder() { return new Builder(); }
    public override pb::IBuilderLite ToBuilder() { return CreateBuilder(this); }
    public override pb::IBuilderLite CreateBuilderForType() { if (IsReused) return Builder.GetReuseBuilder(); else return new Builder(); }
    public static Builder CreateBuilder(C2A_AuthSyn prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite {
      protected override pb::IBuilderLite ThisBuilder {
        get { return this; }
      }
      public Builder() {
        resultIsReadOnly = true;
      }
      internal Builder(C2A_AuthSyn cloneFrom) {
        __result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private C2A_AuthSyn __result;
      
      private static Builder _reuseBuilder;
      
      private C2A_AuthSyn PrepareBuilder() {
        if (resultIsReadOnly) {
          __result = new C2A_AuthSyn();
          resultIsReadOnly = false;
        }
        return __result;
      }
      
      public override bool IsInitialized {
        get { return __result.IsInitialized; }
      }
      
      protected override pb::GeneratedMessageLite MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override pb::IBuilderLite Clear() {
        resultIsReadOnly = true;
        return this;
      }
      
      public override pb::IMessageLite BuildPartial() {
        if (resultIsReadOnly) {
          return __result;
        }
        resultIsReadOnly = true;
        return __result;
      }
      
      public override pb::IMessageLite BuildEmpty(){
        C2A_AuthSyn message = new C2A_AuthSyn();
        message.IsReused = IsReuseMode;
        return message;
      }
      
      public static C2A_AuthSyn.Builder GetReuseBuilder(){
        if (_reuseBuilder == null) _reuseBuilder = new Builder();
        _reuseBuilder.IsReuseMode = true;
        return _reuseBuilder;
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, null);
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input, pb::IMessageLite target) {
        if(!(target is C2A_AuthSyn)) {throw new System.Exception("Target is error Type or Null");}
        __result = target as C2A_AuthSyn;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_c2AAuthSynFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _c2AAuthSynFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, tag, field_name);
              break;
            }
            case 10: {
              __result.hasdhpubkey_client = input.ReadBytes(ref __result.dhpubkeyClient_);
              break;
            }
            case 18: {
              __result.hasaccount_info = input.ReadBytes(ref __result.accountInfo_);
              break;
            }
            case 26: {
              __result.hastoken = input.ReadString(ref __result.token_);
              break;
            }
            case 32: {
              __result.hasenet_player_uin = input.ReadUInt64(ref __result.enetPlayerUin_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      
      
      
    }
  }
  
  public sealed partial class A2C_AuthSynAck : pb::GeneratedMessageLite {
    public A2C_AuthSynAck() { }
    private static readonly string[] _a2CAuthSynAckFieldNames = new string[] { "compress", "dhpubkey_server", "encrypt", "player_uin" };
    private static readonly scg::List<uint> _a2CAuthSynAckFieldTags = new scg::List<uint> { 24, 10, 16, 32 };
    
    
    public const int dhpubkey_serverFieldNumber = 1;
    private bool hasdhpubkey_server;
    private pb::ByteString dhpubkeyServer_ = pb::ByteString.Empty;
    public bool Hasdhpubkey_server {
      get { return hasdhpubkey_server; }
    }
    public pb::ByteString dhpubkey_server {
      get { return dhpubkeyServer_; }
      set { hasdhpubkey_server = true; dhpubkeyServer_ = value;}
    }
    
    public const int encryptFieldNumber = 2;
    private bool hasencrypt;
    private global::proto_client2access.Proto_C2AEncryptType encrypt_ = global::proto_client2access.Proto_C2AEncryptType.E_AES;
    public bool Hasencrypt {
      get { return hasencrypt; }
    }
    public global::proto_client2access.Proto_C2AEncryptType encrypt {
      get { return encrypt_; }
      set { hasencrypt = true; encrypt_ = value;}
    }
    
    public const int compressFieldNumber = 3;
    private bool hascompress;
    private global::proto_client2access.Proto_C2ACompressType compress_ = global::proto_client2access.Proto_C2ACompressType.E_SNAPPY;
    public bool Hascompress {
      get { return hascompress; }
    }
    public global::proto_client2access.Proto_C2ACompressType compress {
      get { return compress_; }
      set { hascompress = true; compress_ = value;}
    }
    
    public const int player_uinFieldNumber = 4;
    private bool hasplayer_uin;
    private ulong playerUin_;
    public bool Hasplayer_uin {
      get { return hasplayer_uin; }
    }
    [global::System.CLSCompliant(false)]
    public ulong player_uin {
      get { return playerUin_; }
      set { hasplayer_uin = true; playerUin_ = value;}
    }
    
    public override bool IsInitialized {
      get {
        if (!hasdhpubkey_server)return false;
        if (!hasencrypt)hasencrypt = true;
        if (!hascompress)hascompress = true;
        if (!hasplayer_uin)hasplayer_uin = true;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _a2CAuthSynAckFieldNames;
      if (hasdhpubkey_server) {
        output.WriteBytes(1, field_names[1], dhpubkey_server);
      }
      if (hasencrypt) {
        output.WriteEnum(2, field_names[2], (int) encrypt, encrypt);
      }
      if (hascompress) {
        output.WriteEnum(3, field_names[0], (int) compress, compress);
      }
      if (hasplayer_uin) {
        output.WriteUInt64(4, field_names[3], player_uin);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasdhpubkey_server) {
        size += pb::CodedOutputStream.ComputeBytesSize(1, dhpubkey_server);
      }
      if (hasencrypt) {
        size += pb::CodedOutputStream.ComputeEnumSize(2, (int) encrypt);
      }
      if (hascompress) {
        size += pb::CodedOutputStream.ComputeEnumSize(3, (int) compress);
      }
      if (hasplayer_uin) {
        size += pb::CodedOutputStream.ComputeUInt64Size(4, player_uin);
      }
      memoizedSerializedSize = size;
      return size;
    }
    public override void Reset(bool recursive = true, bool reuse = false)
    {
      dhpubkeyServer_ = pb::ByteString.Empty;
      hasdhpubkey_server = false;
      encrypt_ = global::proto_client2access.Proto_C2AEncryptType.E_AES;
      hasencrypt = false;
      compress_ = global::proto_client2access.Proto_C2ACompressType.E_SNAPPY;
      hascompress = false;
      playerUin_ = 0UL;
      hasplayer_uin = false;
      memoizedSerializedSize = -1;
      base.Reset(recursive, reuse);
    }
    public static Builder CreateBuilder() { return new Builder(); }
    public override pb::IBuilderLite ToBuilder() { return CreateBuilder(this); }
    public override pb::IBuilderLite CreateBuilderForType() { if (IsReused) return Builder.GetReuseBuilder(); else return new Builder(); }
    public static Builder CreateBuilder(A2C_AuthSynAck prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite {
      protected override pb::IBuilderLite ThisBuilder {
        get { return this; }
      }
      public Builder() {
        resultIsReadOnly = true;
      }
      internal Builder(A2C_AuthSynAck cloneFrom) {
        __result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private A2C_AuthSynAck __result;
      
      private static Builder _reuseBuilder;
      
      private A2C_AuthSynAck PrepareBuilder() {
        if (resultIsReadOnly) {
          __result = new A2C_AuthSynAck();
          resultIsReadOnly = false;
        }
        return __result;
      }
      
      public override bool IsInitialized {
        get { return __result.IsInitialized; }
      }
      
      protected override pb::GeneratedMessageLite MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override pb::IBuilderLite Clear() {
        resultIsReadOnly = true;
        return this;
      }
      
      public override pb::IMessageLite BuildPartial() {
        if (resultIsReadOnly) {
          return __result;
        }
        resultIsReadOnly = true;
        return __result;
      }
      
      public override pb::IMessageLite BuildEmpty(){
        A2C_AuthSynAck message = new A2C_AuthSynAck();
        message.IsReused = IsReuseMode;
        return message;
      }
      
      public static A2C_AuthSynAck.Builder GetReuseBuilder(){
        if (_reuseBuilder == null) _reuseBuilder = new Builder();
        _reuseBuilder.IsReuseMode = true;
        return _reuseBuilder;
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, null);
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input, pb::IMessageLite target) {
        if(!(target is A2C_AuthSynAck)) {throw new System.Exception("Target is error Type or Null");}
        __result = target as A2C_AuthSynAck;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_a2CAuthSynAckFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _a2CAuthSynAckFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, tag, field_name);
              break;
            }
            case 10: {
              __result.hasdhpubkey_server = input.ReadBytes(ref __result.dhpubkeyServer_);
              break;
            }
            case 16: {
              object unknown;
              if(input.ReadEnum(ref __result.encrypt_, out unknown)) {
                __result.hasencrypt = true;
              } else if(unknown is int) {
              }
              break;
            }
            case 24: {
              object unknown;
              if(input.ReadEnum(ref __result.compress_, out unknown)) {
                __result.hascompress = true;
              } else if(unknown is int) {
              }
              break;
            }
            case 32: {
              __result.hasplayer_uin = input.ReadUInt64(ref __result.playerUin_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      
      
      
    }
  }
  
  public sealed partial class C2A_AuthAck : pb::GeneratedMessageLite {
    public C2A_AuthAck() { }
    private static readonly string[] _c2AAuthAckFieldNames = new string[] { "cipher_text", "plain_text" };
    private static readonly scg::List<uint> _c2AAuthAckFieldTags = new scg::List<uint> { 10, 18 };
    
    
    public const int cipher_textFieldNumber = 1;
    private bool hascipher_text;
    private pb::ByteString cipherText_ = pb::ByteString.Empty;
    public bool Hascipher_text {
      get { return hascipher_text; }
    }
    public pb::ByteString cipher_text {
      get { return cipherText_; }
      set { hascipher_text = true; cipherText_ = value;}
    }
    
    public const int plain_textFieldNumber = 2;
    private bool hasplain_text;
    private pb::ByteString plainText_ = pb::ByteString.Empty;
    public bool Hasplain_text {
      get { return hasplain_text; }
    }
    public pb::ByteString plain_text {
      get { return plainText_; }
      set { hasplain_text = true; plainText_ = value;}
    }
    
    public override bool IsInitialized {
      get {
        if (!hascipher_text)return false;
        if (!hasplain_text)return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _c2AAuthAckFieldNames;
      if (hascipher_text) {
        output.WriteBytes(1, field_names[0], cipher_text);
      }
      if (hasplain_text) {
        output.WriteBytes(2, field_names[1], plain_text);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hascipher_text) {
        size += pb::CodedOutputStream.ComputeBytesSize(1, cipher_text);
      }
      if (hasplain_text) {
        size += pb::CodedOutputStream.ComputeBytesSize(2, plain_text);
      }
      memoizedSerializedSize = size;
      return size;
    }
    public override void Reset(bool recursive = true, bool reuse = false)
    {
      cipherText_ = pb::ByteString.Empty;
      hascipher_text = false;
      plainText_ = pb::ByteString.Empty;
      hasplain_text = false;
      memoizedSerializedSize = -1;
      base.Reset(recursive, reuse);
    }
    public static Builder CreateBuilder() { return new Builder(); }
    public override pb::IBuilderLite ToBuilder() { return CreateBuilder(this); }
    public override pb::IBuilderLite CreateBuilderForType() { if (IsReused) return Builder.GetReuseBuilder(); else return new Builder(); }
    public static Builder CreateBuilder(C2A_AuthAck prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite {
      protected override pb::IBuilderLite ThisBuilder {
        get { return this; }
      }
      public Builder() {
        resultIsReadOnly = true;
      }
      internal Builder(C2A_AuthAck cloneFrom) {
        __result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private C2A_AuthAck __result;
      
      private static Builder _reuseBuilder;
      
      private C2A_AuthAck PrepareBuilder() {
        if (resultIsReadOnly) {
          __result = new C2A_AuthAck();
          resultIsReadOnly = false;
        }
        return __result;
      }
      
      public override bool IsInitialized {
        get { return __result.IsInitialized; }
      }
      
      protected override pb::GeneratedMessageLite MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override pb::IBuilderLite Clear() {
        resultIsReadOnly = true;
        return this;
      }
      
      public override pb::IMessageLite BuildPartial() {
        if (resultIsReadOnly) {
          return __result;
        }
        resultIsReadOnly = true;
        return __result;
      }
      
      public override pb::IMessageLite BuildEmpty(){
        C2A_AuthAck message = new C2A_AuthAck();
        message.IsReused = IsReuseMode;
        return message;
      }
      
      public static C2A_AuthAck.Builder GetReuseBuilder(){
        if (_reuseBuilder == null) _reuseBuilder = new Builder();
        _reuseBuilder.IsReuseMode = true;
        return _reuseBuilder;
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, null);
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input, pb::IMessageLite target) {
        if(!(target is C2A_AuthAck)) {throw new System.Exception("Target is error Type or Null");}
        __result = target as C2A_AuthAck;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_c2AAuthAckFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _c2AAuthAckFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, tag, field_name);
              break;
            }
            case 10: {
              __result.hascipher_text = input.ReadBytes(ref __result.cipherText_);
              break;
            }
            case 18: {
              __result.hasplain_text = input.ReadBytes(ref __result.plainText_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      
    }
  }
  
  public sealed partial class TransferData : pb::GeneratedMessageLite {
    public TransferData() { }
    private static readonly string[] _transferDataFieldNames = new string[] { "app_msg_cmd", "app_msg_data" };
    private static readonly scg::List<uint> _transferDataFieldTags = new scg::List<uint> { 8, 18 };
    
    
    public const int app_msg_cmdFieldNumber = 1;
    private bool hasapp_msg_cmd;
    private uint appMsgCmd_;
    public bool Hasapp_msg_cmd {
      get { return hasapp_msg_cmd; }
    }
    [global::System.CLSCompliant(false)]
    public uint app_msg_cmd {
      get { return appMsgCmd_; }
      set { hasapp_msg_cmd = true; appMsgCmd_ = value;}
    }
    
    public const int app_msg_dataFieldNumber = 2;
    private bool hasapp_msg_data;
    private pb::ByteString appMsgData_ = pb::ByteString.Empty;
    public bool Hasapp_msg_data {
      get { return hasapp_msg_data; }
    }
    public pb::ByteString app_msg_data {
      get { return appMsgData_; }
      set { hasapp_msg_data = true; appMsgData_ = value;}
    }
    
    public override bool IsInitialized {
      get {
        if (!hasapp_msg_cmd)hasapp_msg_cmd = true;
        if (!hasapp_msg_data)return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _transferDataFieldNames;
      if (hasapp_msg_cmd) {
        output.WriteUInt32(1, field_names[0], app_msg_cmd);
      }
      if (hasapp_msg_data) {
        output.WriteBytes(2, field_names[1], app_msg_data);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasapp_msg_cmd) {
        size += pb::CodedOutputStream.ComputeUInt32Size(1, app_msg_cmd);
      }
      if (hasapp_msg_data) {
        size += pb::CodedOutputStream.ComputeBytesSize(2, app_msg_data);
      }
      memoizedSerializedSize = size;
      return size;
    }
    public override void Reset(bool recursive = true, bool reuse = false)
    {
      appMsgCmd_ = 0;
      hasapp_msg_cmd = false;
      appMsgData_ = pb::ByteString.Empty;
      hasapp_msg_data = false;
      memoizedSerializedSize = -1;
      base.Reset(recursive, reuse);
    }
    public static Builder CreateBuilder() { return new Builder(); }
    public override pb::IBuilderLite ToBuilder() { return CreateBuilder(this); }
    public override pb::IBuilderLite CreateBuilderForType() { if (IsReused) return Builder.GetReuseBuilder(); else return new Builder(); }
    public static Builder CreateBuilder(TransferData prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite {
      protected override pb::IBuilderLite ThisBuilder {
        get { return this; }
      }
      public Builder() {
        resultIsReadOnly = true;
      }
      internal Builder(TransferData cloneFrom) {
        __result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private TransferData __result;
      
      private static Builder _reuseBuilder;
      
      private TransferData PrepareBuilder() {
        if (resultIsReadOnly) {
          __result = new TransferData();
          resultIsReadOnly = false;
        }
        return __result;
      }
      
      public override bool IsInitialized {
        get { return __result.IsInitialized; }
      }
      
      protected override pb::GeneratedMessageLite MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override pb::IBuilderLite Clear() {
        resultIsReadOnly = true;
        return this;
      }
      
      public override pb::IMessageLite BuildPartial() {
        if (resultIsReadOnly) {
          return __result;
        }
        resultIsReadOnly = true;
        return __result;
      }
      
      public override pb::IMessageLite BuildEmpty(){
        TransferData message = new TransferData();
        message.IsReused = IsReuseMode;
        return message;
      }
      
      public static TransferData.Builder GetReuseBuilder(){
        if (_reuseBuilder == null) _reuseBuilder = new Builder();
        _reuseBuilder.IsReuseMode = true;
        return _reuseBuilder;
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, null);
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input, pb::IMessageLite target) {
        if(!(target is TransferData)) {throw new System.Exception("Target is error Type or Null");}
        __result = target as TransferData;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_transferDataFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _transferDataFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, tag, field_name);
              break;
            }
            case 8: {
              __result.hasapp_msg_cmd = input.ReadUInt32(ref __result.appMsgCmd_);
              break;
            }
            case 18: {
              __result.hasapp_msg_data = input.ReadBytes(ref __result.appMsgData_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      
    }
  }
  
  public sealed partial class C2A_Keepalived : pb::GeneratedMessageLite {
    public C2A_Keepalived() { }
    private static readonly string[] _c2AKeepalivedFieldNames = new string[] { "c2a_timestamp" };
    private static readonly scg::List<uint> _c2AKeepalivedFieldTags = new scg::List<uint> { 8 };
    
    
    public const int c2a_timestampFieldNumber = 1;
    private bool hasc2a_timestamp;
    private ulong c2ATimestamp_;
    public bool Hasc2a_timestamp {
      get { return hasc2a_timestamp; }
    }
    [global::System.CLSCompliant(false)]
    public ulong c2a_timestamp {
      get { return c2ATimestamp_; }
      set { hasc2a_timestamp = true; c2ATimestamp_ = value;}
    }
    
    public override bool IsInitialized {
      get {
        if (!hasc2a_timestamp)hasc2a_timestamp = true;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _c2AKeepalivedFieldNames;
      if (hasc2a_timestamp) {
        output.WriteUInt64(1, field_names[0], c2a_timestamp);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasc2a_timestamp) {
        size += pb::CodedOutputStream.ComputeUInt64Size(1, c2a_timestamp);
      }
      memoizedSerializedSize = size;
      return size;
    }
    public override void Reset(bool recursive = true, bool reuse = false)
    {
      c2ATimestamp_ = 0UL;
      hasc2a_timestamp = false;
      memoizedSerializedSize = -1;
      base.Reset(recursive, reuse);
    }
    public static Builder CreateBuilder() { return new Builder(); }
    public override pb::IBuilderLite ToBuilder() { return CreateBuilder(this); }
    public override pb::IBuilderLite CreateBuilderForType() { if (IsReused) return Builder.GetReuseBuilder(); else return new Builder(); }
    public static Builder CreateBuilder(C2A_Keepalived prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite {
      protected override pb::IBuilderLite ThisBuilder {
        get { return this; }
      }
      public Builder() {
        resultIsReadOnly = true;
      }
      internal Builder(C2A_Keepalived cloneFrom) {
        __result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private C2A_Keepalived __result;
      
      private static Builder _reuseBuilder;
      
      private C2A_Keepalived PrepareBuilder() {
        if (resultIsReadOnly) {
          __result = new C2A_Keepalived();
          resultIsReadOnly = false;
        }
        return __result;
      }
      
      public override bool IsInitialized {
        get { return __result.IsInitialized; }
      }
      
      protected override pb::GeneratedMessageLite MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override pb::IBuilderLite Clear() {
        resultIsReadOnly = true;
        return this;
      }
      
      public override pb::IMessageLite BuildPartial() {
        if (resultIsReadOnly) {
          return __result;
        }
        resultIsReadOnly = true;
        return __result;
      }
      
      public override pb::IMessageLite BuildEmpty(){
        C2A_Keepalived message = new C2A_Keepalived();
        message.IsReused = IsReuseMode;
        return message;
      }
      
      public static C2A_Keepalived.Builder GetReuseBuilder(){
        if (_reuseBuilder == null) _reuseBuilder = new Builder();
        _reuseBuilder.IsReuseMode = true;
        return _reuseBuilder;
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, null);
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input, pb::IMessageLite target) {
        if(!(target is C2A_Keepalived)) {throw new System.Exception("Target is error Type or Null");}
        __result = target as C2A_Keepalived;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_c2AKeepalivedFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _c2AKeepalivedFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, tag, field_name);
              break;
            }
            case 8: {
              __result.hasc2a_timestamp = input.ReadUInt64(ref __result.c2ATimestamp_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
    }
  }
  
  public sealed partial class A2C_Keepalived : pb::GeneratedMessageLite {
    public A2C_Keepalived() { }
    private static readonly string[] _a2CKeepalivedFieldNames = new string[] { "a2c_timestamp" };
    private static readonly scg::List<uint> _a2CKeepalivedFieldTags = new scg::List<uint> { 16 };
    
    
    public const int a2c_timestampFieldNumber = 2;
    private bool hasa2c_timestamp;
    private ulong a2CTimestamp_;
    public bool Hasa2c_timestamp {
      get { return hasa2c_timestamp; }
    }
    [global::System.CLSCompliant(false)]
    public ulong a2c_timestamp {
      get { return a2CTimestamp_; }
      set { hasa2c_timestamp = true; a2CTimestamp_ = value;}
    }
    
    public override bool IsInitialized {
      get {
        if (!hasa2c_timestamp)hasa2c_timestamp = true;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _a2CKeepalivedFieldNames;
      if (hasa2c_timestamp) {
        output.WriteUInt64(2, field_names[0], a2c_timestamp);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasa2c_timestamp) {
        size += pb::CodedOutputStream.ComputeUInt64Size(2, a2c_timestamp);
      }
      memoizedSerializedSize = size;
      return size;
    }
    public override void Reset(bool recursive = true, bool reuse = false)
    {
      a2CTimestamp_ = 0UL;
      hasa2c_timestamp = false;
      memoizedSerializedSize = -1;
      base.Reset(recursive, reuse);
    }
    public static Builder CreateBuilder() { return new Builder(); }
    public override pb::IBuilderLite ToBuilder() { return CreateBuilder(this); }
    public override pb::IBuilderLite CreateBuilderForType() { if (IsReused) return Builder.GetReuseBuilder(); else return new Builder(); }
    public static Builder CreateBuilder(A2C_Keepalived prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite {
      protected override pb::IBuilderLite ThisBuilder {
        get { return this; }
      }
      public Builder() {
        resultIsReadOnly = true;
      }
      internal Builder(A2C_Keepalived cloneFrom) {
        __result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private A2C_Keepalived __result;
      
      private static Builder _reuseBuilder;
      
      private A2C_Keepalived PrepareBuilder() {
        if (resultIsReadOnly) {
          __result = new A2C_Keepalived();
          resultIsReadOnly = false;
        }
        return __result;
      }
      
      public override bool IsInitialized {
        get { return __result.IsInitialized; }
      }
      
      protected override pb::GeneratedMessageLite MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override pb::IBuilderLite Clear() {
        resultIsReadOnly = true;
        return this;
      }
      
      public override pb::IMessageLite BuildPartial() {
        if (resultIsReadOnly) {
          return __result;
        }
        resultIsReadOnly = true;
        return __result;
      }
      
      public override pb::IMessageLite BuildEmpty(){
        A2C_Keepalived message = new A2C_Keepalived();
        message.IsReused = IsReuseMode;
        return message;
      }
      
      public static A2C_Keepalived.Builder GetReuseBuilder(){
        if (_reuseBuilder == null) _reuseBuilder = new Builder();
        _reuseBuilder.IsReuseMode = true;
        return _reuseBuilder;
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, null);
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input, pb::IMessageLite target) {
        if(!(target is A2C_Keepalived)) {throw new System.Exception("Target is error Type or Null");}
        __result = target as A2C_Keepalived;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_a2CKeepalivedFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _a2CKeepalivedFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, tag, field_name);
              break;
            }
            case 16: {
              __result.hasa2c_timestamp = input.ReadUInt64(ref __result.a2CTimestamp_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
    }
  }
  
  public sealed partial class C2AMsgHead : pb::GeneratedMessageLite {
    public C2AMsgHead() { }
    private static readonly string[] _c2AMsgHeadFieldNames = new string[] { "cmd", "magic", "msg_seq", "transferdata_len" };
    private static readonly scg::List<uint> _c2AMsgHeadFieldTags = new scg::List<uint> { 32, 16, 8, 40 };
    
    
    public const int msg_seqFieldNumber = 1;
    private bool hasmsg_seq;
    private uint msgSeq_;
    public bool Hasmsg_seq {
      get { return hasmsg_seq; }
    }
    [global::System.CLSCompliant(false)]
    public uint msg_seq {
      get { return msgSeq_; }
      set { hasmsg_seq = true; msgSeq_ = value;}
    }
    
    public const int magicFieldNumber = 2;
    private bool hasmagic;
    private int magic_ = 26214;
    public bool Hasmagic {
      get { return hasmagic; }
    }
    public int magic {
      get { return magic_; }
      set { hasmagic = true; magic_ = value;}
    }
    
    public const int cmdFieldNumber = 4;
    private bool hascmd;
    private global::proto_client2access.Proto_C2ACmd cmd_ = global::proto_client2access.Proto_C2ACmd.E_C2A_AUTH_SYN;
    public bool Hascmd {
      get { return hascmd; }
    }
    public global::proto_client2access.Proto_C2ACmd cmd {
      get { return cmd_; }
      set { hascmd = true; cmd_ = value;}
    }
    
    public const int transferdata_lenFieldNumber = 5;
    private bool hastransferdata_len;
    private uint transferdataLen_;
    public bool Hastransferdata_len {
      get { return hastransferdata_len; }
    }
    [global::System.CLSCompliant(false)]
    public uint transferdata_len {
      get { return transferdataLen_; }
      set { hastransferdata_len = true; transferdataLen_ = value;}
    }
    
    public override bool IsInitialized {
      get {
        if (!hasmsg_seq)hasmsg_seq = true;
        if (!hasmagic)hasmagic = true;
        if (!hascmd)hascmd = true;
        if (!hastransferdata_len)hastransferdata_len = true;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _c2AMsgHeadFieldNames;
      if (hasmsg_seq) {
        output.WriteUInt32(1, field_names[2], msg_seq);
      }
      if (hasmagic) {
        output.WriteInt32(2, field_names[1], magic);
      }
      if (hascmd) {
        output.WriteEnum(4, field_names[0], (int) cmd, cmd);
      }
      if (hastransferdata_len) {
        output.WriteUInt32(5, field_names[3], transferdata_len);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasmsg_seq) {
        size += pb::CodedOutputStream.ComputeUInt32Size(1, msg_seq);
      }
      if (hasmagic) {
        size += pb::CodedOutputStream.ComputeInt32Size(2, magic);
      }
      if (hascmd) {
        size += pb::CodedOutputStream.ComputeEnumSize(4, (int) cmd);
      }
      if (hastransferdata_len) {
        size += pb::CodedOutputStream.ComputeUInt32Size(5, transferdata_len);
      }
      memoizedSerializedSize = size;
      return size;
    }
    public override void Reset(bool recursive = true, bool reuse = false)
    {
      msgSeq_ = 0;
      hasmsg_seq = false;
      magic_ = 26214;
      hasmagic = false;
      cmd_ = global::proto_client2access.Proto_C2ACmd.E_C2A_AUTH_SYN;
      hascmd = false;
      transferdataLen_ = 0;
      hastransferdata_len = false;
      memoizedSerializedSize = -1;
      base.Reset(recursive, reuse);
    }
    public static Builder CreateBuilder() { return new Builder(); }
    public override pb::IBuilderLite ToBuilder() { return CreateBuilder(this); }
    public override pb::IBuilderLite CreateBuilderForType() { if (IsReused) return Builder.GetReuseBuilder(); else return new Builder(); }
    public static Builder CreateBuilder(C2AMsgHead prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite {
      protected override pb::IBuilderLite ThisBuilder {
        get { return this; }
      }
      public Builder() {
        resultIsReadOnly = true;
      }
      internal Builder(C2AMsgHead cloneFrom) {
        __result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private C2AMsgHead __result;
      
      private static Builder _reuseBuilder;
      
      private C2AMsgHead PrepareBuilder() {
        if (resultIsReadOnly) {
          __result = new C2AMsgHead();
          resultIsReadOnly = false;
        }
        return __result;
      }
      
      public override bool IsInitialized {
        get { return __result.IsInitialized; }
      }
      
      protected override pb::GeneratedMessageLite MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override pb::IBuilderLite Clear() {
        resultIsReadOnly = true;
        return this;
      }
      
      public override pb::IMessageLite BuildPartial() {
        if (resultIsReadOnly) {
          return __result;
        }
        resultIsReadOnly = true;
        return __result;
      }
      
      public override pb::IMessageLite BuildEmpty(){
        C2AMsgHead message = new C2AMsgHead();
        message.IsReused = IsReuseMode;
        return message;
      }
      
      public static C2AMsgHead.Builder GetReuseBuilder(){
        if (_reuseBuilder == null) _reuseBuilder = new Builder();
        _reuseBuilder.IsReuseMode = true;
        return _reuseBuilder;
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, null);
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input, pb::IMessageLite target) {
        if(!(target is C2AMsgHead)) {throw new System.Exception("Target is error Type or Null");}
        __result = target as C2AMsgHead;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_c2AMsgHeadFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _c2AMsgHeadFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, tag, field_name);
              break;
            }
            case 8: {
              __result.hasmsg_seq = input.ReadUInt32(ref __result.msgSeq_);
              break;
            }
            case 16: {
              __result.hasmagic = input.ReadInt32(ref __result.magic_);
              break;
            }
            case 32: {
              object unknown;
              if(input.ReadEnum(ref __result.cmd_, out unknown)) {
                __result.hascmd = true;
              } else if(unknown is int) {
              }
              break;
            }
            case 40: {
              __result.hastransferdata_len = input.ReadUInt32(ref __result.transferdataLen_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      
      
      
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
