// Generated by ProtoGen, Version=2.4.1.555, Culture=neutral, PublicKeyToken=17b3b1f090c3ea48.  DO NOT EDIT!
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace Google.ProtocolBuffers.DescriptorProtos {
  
  
  #region Messages
  public sealed partial class FileDescriptorSet : pb::GeneratedMessageLite {
    public FileDescriptorSet() { }
    private static readonly string[] _fileDescriptorSetFieldNames = new string[] { "file" };
    private static readonly scg::List<uint> _fileDescriptorSetFieldTags = new scg::List<uint> { 10 };
    
    
    public const int fileFieldNumber = 1;
    private scg::List<global::Google.ProtocolBuffers.DescriptorProtos.FileDescriptorProto> file_ = new scg::List<global::Google.ProtocolBuffers.DescriptorProtos.FileDescriptorProto>();
    public scg::List<global::Google.ProtocolBuffers.DescriptorProtos.FileDescriptorProto> file {
      get { return file_; }
    }
    public int fileCount {
      get { return file_.Count; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.FileDescriptorProto Getfile(int index) {
      return file_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::Google.ProtocolBuffers.DescriptorProtos.FileDescriptorProto element in file) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _fileDescriptorSetFieldNames;
      if (file_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], file_);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      foreach (global::Google.ProtocolBuffers.DescriptorProtos.FileDescriptorProto element in file) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, element);
      }
      memoizedSerializedSize = size;
      return size;
    }
    public override void Reset(bool recursive = true, bool reuse = false)
    {
     if(recursive) for (int i = 0; i <file_.Count; i++) file_[i].Reset(recursive, reuse);
      file_.Clear();
      memoizedSerializedSize = -1;
      base.Reset(recursive, reuse);
    }
    public static Builder CreateBuilder() { return new Builder(); }
    public override pb::IBuilderLite ToBuilder() { return CreateBuilder(this); }
    public override pb::IBuilderLite CreateBuilderForType() { if (IsReused) return Builder.GetReuseBuilder(); else return new Builder(); }
    public static Builder CreateBuilder(FileDescriptorSet prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite {
      protected override pb::IBuilderLite ThisBuilder {
        get { return this; }
      }
      public Builder() {
        resultIsReadOnly = true;
      }
      internal Builder(FileDescriptorSet cloneFrom) {
        __result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private FileDescriptorSet __result;
      
      private static Builder _reuseBuilder;
      
      private FileDescriptorSet PrepareBuilder() {
        if (resultIsReadOnly) {
          __result = new FileDescriptorSet();
          resultIsReadOnly = false;
        }
        return __result;
      }
      
      public override bool IsInitialized {
        get { return __result.IsInitialized; }
      }
      
      protected override pb::GeneratedMessageLite MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override pb::IBuilderLite Clear() {
        resultIsReadOnly = true;
        return this;
      }
      
      public override pb::IMessageLite BuildPartial() {
        if (resultIsReadOnly) {
          return __result;
        }
        resultIsReadOnly = true;
        return __result;
      }
      
      public override pb::IMessageLite BuildEmpty(){
        FileDescriptorSet message = new FileDescriptorSet();
        message.IsReused = IsReuseMode;
        return message;
      }
      
      public static FileDescriptorSet.Builder GetReuseBuilder(){
        if (_reuseBuilder == null) _reuseBuilder = new Builder();
        _reuseBuilder.IsReuseMode = true;
        return _reuseBuilder;
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, null);
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input, pb::IMessageLite target) {
        if(!(target is FileDescriptorSet)) {throw new System.Exception("Target is error Type or Null");}
        __result = target as FileDescriptorSet;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_fileDescriptorSetFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _fileDescriptorSetFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, tag, field_name);
              break;
            }
            case 10: {
              if (IsReuseMode) input.ReadMessageArrayReuse(tag, field_name, __result.file_, global::Google.ProtocolBuffers.DescriptorProtos.FileDescriptorProto.Builder.GetReuseBuilder());
              break;
            }
          }
        }
        
        return this;
      }
      
      
    }
  }
  
  public sealed partial class FileDescriptorProto : pb::GeneratedMessageLite {
    public FileDescriptorProto() { }
    private static readonly string[] _fileDescriptorProtoFieldNames = new string[] { "dependency", "enum_type", "extension", "message_type", "name", "options", "package", "public_dependency", "service", "source_code_info", "weak_dependency" };
    private static readonly scg::List<uint> _fileDescriptorProtoFieldTags = new scg::List<uint> { 26, 42, 58, 34, 10, 66, 18, 80, 50, 74, 88 };
    
    
    public const int nameFieldNumber = 1;
    private bool hasname;
    private string name_ = "";
    public bool Hasname {
      get { return hasname; }
    }
    public string name {
      get { return name_; }
      set { hasname = true; name_ = value;}
    }
    
    public const int packageFieldNumber = 2;
    private bool haspackage;
    private string package_ = "";
    public bool Haspackage {
      get { return haspackage; }
    }
    public string package {
      get { return package_; }
      set { haspackage = true; package_ = value;}
    }
    
    public const int dependencyFieldNumber = 3;
    private scg::List<string> dependency_ = new scg::List<string>();
    public scg::List<string> dependency {
      get { return dependency_; }
    }
    public int dependencyCount {
      get { return dependency_.Count; }
    }
    public string Getdependency(int index) {
      return dependency_[index];
    }
    
    public const int public_dependencyFieldNumber = 10;
    private scg::List<int> publicDependency_ = new scg::List<int>();
    public scg::List<int> public_dependency {
      get { return publicDependency_; }
    }
    public int public_dependencyCount {
      get { return publicDependency_.Count; }
    }
    public int Getpublic_dependency(int index) {
      return publicDependency_[index];
    }
    
    public const int weak_dependencyFieldNumber = 11;
    private scg::List<int> weakDependency_ = new scg::List<int>();
    public scg::List<int> weak_dependency {
      get { return weakDependency_; }
    }
    public int weak_dependencyCount {
      get { return weakDependency_.Count; }
    }
    public int Getweak_dependency(int index) {
      return weakDependency_[index];
    }
    
    public const int message_typeFieldNumber = 4;
    private scg::List<global::Google.ProtocolBuffers.DescriptorProtos.DescriptorProto> messageType_ = new scg::List<global::Google.ProtocolBuffers.DescriptorProtos.DescriptorProto>();
    public scg::List<global::Google.ProtocolBuffers.DescriptorProtos.DescriptorProto> message_type {
      get { return messageType_; }
    }
    public int message_typeCount {
      get { return messageType_.Count; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.DescriptorProto Getmessage_type(int index) {
      return messageType_[index];
    }
    
    public const int enum_typeFieldNumber = 5;
    private scg::List<global::Google.ProtocolBuffers.DescriptorProtos.EnumDescriptorProto> enumType_ = new scg::List<global::Google.ProtocolBuffers.DescriptorProtos.EnumDescriptorProto>();
    public scg::List<global::Google.ProtocolBuffers.DescriptorProtos.EnumDescriptorProto> enum_type {
      get { return enumType_; }
    }
    public int enum_typeCount {
      get { return enumType_.Count; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.EnumDescriptorProto Getenum_type(int index) {
      return enumType_[index];
    }
    
    public const int serviceFieldNumber = 6;
    private scg::List<global::Google.ProtocolBuffers.DescriptorProtos.ServiceDescriptorProto> service_ = new scg::List<global::Google.ProtocolBuffers.DescriptorProtos.ServiceDescriptorProto>();
    public scg::List<global::Google.ProtocolBuffers.DescriptorProtos.ServiceDescriptorProto> service {
      get { return service_; }
    }
    public int serviceCount {
      get { return service_.Count; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.ServiceDescriptorProto Getservice(int index) {
      return service_[index];
    }
    
    public const int extensionFieldNumber = 7;
    private scg::List<global::Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto> extension_ = new scg::List<global::Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto>();
    public scg::List<global::Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto> extension {
      get { return extension_; }
    }
    public int extensionCount {
      get { return extension_.Count; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto Getextension(int index) {
      return extension_[index];
    }
    
    public const int optionsFieldNumber = 8;
    private bool hasoptions;
    private global::Google.ProtocolBuffers.DescriptorProtos.FileOptions options_;
    public bool Hasoptions {
      get { return hasoptions; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.FileOptions options {
      get { return options_; }
      set { hasoptions = value != null ? true : false; options_ = value;}
    }
    
    public const int source_code_infoFieldNumber = 9;
    private bool hassource_code_info;
    private global::Google.ProtocolBuffers.DescriptorProtos.SourceCodeInfo sourceCodeInfo_;
    public bool Hassource_code_info {
      get { return hassource_code_info; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.SourceCodeInfo source_code_info {
      get { return sourceCodeInfo_; }
      set { hassource_code_info = value != null ? true : false; sourceCodeInfo_ = value;}
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::Google.ProtocolBuffers.DescriptorProtos.DescriptorProto element in message_type) {
          if (!element.IsInitialized) return false;
        }
        foreach (global::Google.ProtocolBuffers.DescriptorProtos.EnumDescriptorProto element in enum_type) {
          if (!element.IsInitialized) return false;
        }
        foreach (global::Google.ProtocolBuffers.DescriptorProtos.ServiceDescriptorProto element in service) {
          if (!element.IsInitialized) return false;
        }
        foreach (global::Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto element in extension) {
          if (!element.IsInitialized) return false;
        }
        if (Hasoptions) {
          if (!options.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _fileDescriptorProtoFieldNames;
      if (hasname) {
        output.WriteString(1, field_names[4], name);
      }
      if (haspackage) {
        output.WriteString(2, field_names[6], package);
      }
      if (dependency_.Count > 0) {
        output.WriteStringArray(3, field_names[0], dependency_);
      }
      if (messageType_.Count > 0) {
        output.WriteMessageArray(4, field_names[3], messageType_);
      }
      if (enumType_.Count > 0) {
        output.WriteMessageArray(5, field_names[1], enumType_);
      }
      if (service_.Count > 0) {
        output.WriteMessageArray(6, field_names[8], service_);
      }
      if (extension_.Count > 0) {
        output.WriteMessageArray(7, field_names[2], extension_);
      }
      if (hasoptions) {
        output.WriteMessage(8, field_names[5], options);
      }
      if (hassource_code_info) {
        output.WriteMessage(9, field_names[9], source_code_info);
      }
      if (publicDependency_.Count > 0) {
        output.WriteInt32Array(10, field_names[7], publicDependency_);
      }
      if (weakDependency_.Count > 0) {
        output.WriteInt32Array(11, field_names[10], weakDependency_);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasname) {
        size += pb::CodedOutputStream.ComputeStringSize(1, name);
      }
      if (haspackage) {
        size += pb::CodedOutputStream.ComputeStringSize(2, package);
      }
      {
        int dataSize = 0;
        foreach (string element in dependency) {
          dataSize += pb::CodedOutputStream.ComputeStringSizeNoTag(element);
        }
        size += dataSize;
        size += 1 * dependency_.Count;
      }
      {
        int dataSize = 0;
        foreach (int element in public_dependency) {
          dataSize += pb::CodedOutputStream.ComputeInt32SizeNoTag(element);
        }
        size += dataSize;
        size += 1 * publicDependency_.Count;
      }
      {
        int dataSize = 0;
        foreach (int element in weak_dependency) {
          dataSize += pb::CodedOutputStream.ComputeInt32SizeNoTag(element);
        }
        size += dataSize;
        size += 1 * weakDependency_.Count;
      }
      foreach (global::Google.ProtocolBuffers.DescriptorProtos.DescriptorProto element in message_type) {
        size += pb::CodedOutputStream.ComputeMessageSize(4, element);
      }
      foreach (global::Google.ProtocolBuffers.DescriptorProtos.EnumDescriptorProto element in enum_type) {
        size += pb::CodedOutputStream.ComputeMessageSize(5, element);
      }
      foreach (global::Google.ProtocolBuffers.DescriptorProtos.ServiceDescriptorProto element in service) {
        size += pb::CodedOutputStream.ComputeMessageSize(6, element);
      }
      foreach (global::Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto element in extension) {
        size += pb::CodedOutputStream.ComputeMessageSize(7, element);
      }
      if (hasoptions) {
        size += pb::CodedOutputStream.ComputeMessageSize(8, options);
      }
      if (hassource_code_info) {
        size += pb::CodedOutputStream.ComputeMessageSize(9, source_code_info);
      }
      memoizedSerializedSize = size;
      return size;
    }
    public override void Reset(bool recursive = true, bool reuse = false)
    {
      name_ = "";
      hasname = false;
      package_ = "";
      haspackage = false;
      dependency_.Clear();
     if(recursive) for (int i = 0; i <messageType_.Count; i++) messageType_[i].Reset(recursive, reuse);
      messageType_.Clear();
     if(recursive) for (int i = 0; i <enumType_.Count; i++) enumType_[i].Reset(recursive, reuse);
      enumType_.Clear();
     if(recursive) for (int i = 0; i <service_.Count; i++) service_[i].Reset(recursive, reuse);
      service_.Clear();
     if(recursive) for (int i = 0; i <extension_.Count; i++) extension_[i].Reset(recursive, reuse);
      extension_.Clear();
      hasoptions = false;
     if(recursive && options_ != null) options_.Reset(recursive, reuse);
      options_ = null;
      hassource_code_info = false;
     if(recursive && sourceCodeInfo_ != null) sourceCodeInfo_.Reset(recursive, reuse);
      sourceCodeInfo_ = null;
      publicDependency_.Clear();
      weakDependency_.Clear();
      memoizedSerializedSize = -1;
      base.Reset(recursive, reuse);
    }
    public static Builder CreateBuilder() { return new Builder(); }
    public override pb::IBuilderLite ToBuilder() { return CreateBuilder(this); }
    public override pb::IBuilderLite CreateBuilderForType() { if (IsReused) return Builder.GetReuseBuilder(); else return new Builder(); }
    public static Builder CreateBuilder(FileDescriptorProto prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite {
      protected override pb::IBuilderLite ThisBuilder {
        get { return this; }
      }
      public Builder() {
        resultIsReadOnly = true;
      }
      internal Builder(FileDescriptorProto cloneFrom) {
        __result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private FileDescriptorProto __result;
      
      private static Builder _reuseBuilder;
      
      private FileDescriptorProto PrepareBuilder() {
        if (resultIsReadOnly) {
          __result = new FileDescriptorProto();
          resultIsReadOnly = false;
        }
        return __result;
      }
      
      public override bool IsInitialized {
        get { return __result.IsInitialized; }
      }
      
      protected override pb::GeneratedMessageLite MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override pb::IBuilderLite Clear() {
        resultIsReadOnly = true;
        return this;
      }
      
      public override pb::IMessageLite BuildPartial() {
        if (resultIsReadOnly) {
          return __result;
        }
        resultIsReadOnly = true;
        return __result;
      }
      
      public override pb::IMessageLite BuildEmpty(){
        FileDescriptorProto message = new FileDescriptorProto();
        message.IsReused = IsReuseMode;
        return message;
      }
      
      public static FileDescriptorProto.Builder GetReuseBuilder(){
        if (_reuseBuilder == null) _reuseBuilder = new Builder();
        _reuseBuilder.IsReuseMode = true;
        return _reuseBuilder;
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, null);
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input, pb::IMessageLite target) {
        if(!(target is FileDescriptorProto)) {throw new System.Exception("Target is error Type or Null");}
        __result = target as FileDescriptorProto;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_fileDescriptorProtoFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _fileDescriptorProtoFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, tag, field_name);
              break;
            }
            case 10: {
              __result.hasname = input.ReadString(ref __result.name_);
              break;
            }
            case 18: {
              __result.haspackage = input.ReadString(ref __result.package_);
              break;
            }
            case 26: {
              input.ReadStringArray(tag, field_name, __result.dependency_);
              break;
            }
            case 34: {
              if (IsReuseMode) input.ReadMessageArrayReuse(tag, field_name, __result.messageType_, global::Google.ProtocolBuffers.DescriptorProtos.DescriptorProto.Builder.GetReuseBuilder());
              break;
            }
            case 42: {
              if (IsReuseMode) input.ReadMessageArrayReuse(tag, field_name, __result.enumType_, global::Google.ProtocolBuffers.DescriptorProtos.EnumDescriptorProto.Builder.GetReuseBuilder());
              break;
            }
            case 50: {
              if (IsReuseMode) input.ReadMessageArrayReuse(tag, field_name, __result.service_, global::Google.ProtocolBuffers.DescriptorProtos.ServiceDescriptorProto.Builder.GetReuseBuilder());
              break;
            }
            case 58: {
              if (IsReuseMode) input.ReadMessageArrayReuse(tag, field_name, __result.extension_, global::Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto.Builder.GetReuseBuilder());
              break;
            }
            case 66: {
              if (IsReuseMode) __result.options = input.ReadMessageReuse<global::Google.ProtocolBuffers.DescriptorProtos.FileOptions>(global::Google.ProtocolBuffers.DescriptorProtos.FileOptions.Builder.GetReuseBuilder()) as global::Google.ProtocolBuffers.DescriptorProtos.FileOptions;
              break;
            }
            case 74: {
              if (IsReuseMode) __result.source_code_info = input.ReadMessageReuse<global::Google.ProtocolBuffers.DescriptorProtos.SourceCodeInfo>(global::Google.ProtocolBuffers.DescriptorProtos.SourceCodeInfo.Builder.GetReuseBuilder()) as global::Google.ProtocolBuffers.DescriptorProtos.SourceCodeInfo;
              break;
            }
            case 82:
            case 80: {
              input.ReadInt32Array(tag, field_name, __result.publicDependency_);
              break;
            }
            case 90:
            case 88: {
              input.ReadInt32Array(tag, field_name, __result.weakDependency_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      
      
      
      
      
      
      
      
      
      
    }
  }
  
  public sealed partial class DescriptorProto : pb::GeneratedMessageLite {
    public DescriptorProto() { }
    private static readonly string[] _descriptorProtoFieldNames = new string[] { "enum_type", "extension", "extension_range", "field", "name", "nested_type", "options" };
    private static readonly scg::List<uint> _descriptorProtoFieldTags = new scg::List<uint> { 34, 50, 42, 18, 10, 26, 58 };
    
    
    #region Nested types
    public static partial class Types {
      public sealed partial class ExtensionRange : pb::GeneratedMessageLite {
        public ExtensionRange() { }
        private static readonly string[] _extensionRangeFieldNames = new string[] { "end", "start" };
        private static readonly scg::List<uint> _extensionRangeFieldTags = new scg::List<uint> { 16, 8 };
        
        
        public const int startFieldNumber = 1;
        private bool hasstart;
        private int start_;
        public bool Hasstart {
          get { return hasstart; }
        }
        public int start {
          get { return start_; }
          set { hasstart = true; start_ = value;}
        }
        
        public const int endFieldNumber = 2;
        private bool hasend;
        private int end_;
        public bool Hasend {
          get { return hasend; }
        }
        public int end {
          get { return end_; }
          set { hasend = true; end_ = value;}
        }
        
        public override bool IsInitialized {
          get {
            return true;
          }
        }
        
        public override void WriteTo(pb::ICodedOutputStream output) {
          CalcSerializedSize();
          string[] field_names = _extensionRangeFieldNames;
          if (hasstart) {
            output.WriteInt32(1, field_names[1], start);
          }
          if (hasend) {
            output.WriteInt32(2, field_names[0], end);
          }
        }
        
        private int memoizedSerializedSize = -1;
        public override int SerializedSize {
          get {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            return CalcSerializedSize();
          }
        }
        
        private int CalcSerializedSize() {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          
          size = 0;
          if (hasstart) {
            size += pb::CodedOutputStream.ComputeInt32Size(1, start);
          }
          if (hasend) {
            size += pb::CodedOutputStream.ComputeInt32Size(2, end);
          }
          memoizedSerializedSize = size;
          return size;
        }
        public override void Reset(bool recursive = true, bool reuse = false)
        {
          start_ = 0;
          hasstart = false;
          end_ = 0;
          hasend = false;
          memoizedSerializedSize = -1;
          base.Reset(recursive, reuse);
        }
        public static Builder CreateBuilder() { return new Builder(); }
        public override pb::IBuilderLite ToBuilder() { return CreateBuilder(this); }
        public override pb::IBuilderLite CreateBuilderForType() { if (IsReused) return Builder.GetReuseBuilder(); else return new Builder(); }
        public static Builder CreateBuilder(ExtensionRange prototype) {
          return new Builder(prototype);
        }
        
        public sealed partial class Builder : pb::GeneratedBuilderLite {
          protected override pb::IBuilderLite ThisBuilder {
            get { return this; }
          }
          public Builder() {
            resultIsReadOnly = true;
          }
          internal Builder(ExtensionRange cloneFrom) {
            __result = cloneFrom;
            resultIsReadOnly = true;
          }
          
          private bool resultIsReadOnly;
          private ExtensionRange __result;
          
          private static Builder _reuseBuilder;
          
          private ExtensionRange PrepareBuilder() {
            if (resultIsReadOnly) {
              __result = new ExtensionRange();
              resultIsReadOnly = false;
            }
            return __result;
          }
          
          public override bool IsInitialized {
            get { return __result.IsInitialized; }
          }
          
          protected override pb::GeneratedMessageLite MessageBeingBuilt {
            get { return PrepareBuilder(); }
          }
          
          public override pb::IBuilderLite Clear() {
            resultIsReadOnly = true;
            return this;
          }
          
          public override pb::IMessageLite BuildPartial() {
            if (resultIsReadOnly) {
              return __result;
            }
            resultIsReadOnly = true;
            return __result;
          }
          
          public override pb::IMessageLite BuildEmpty(){
            ExtensionRange message = new ExtensionRange();
            message.IsReused = IsReuseMode;
            return message;
          }
          
          public static ExtensionRange.Builder GetReuseBuilder(){
            if (_reuseBuilder == null) _reuseBuilder = new Builder();
            _reuseBuilder.IsReuseMode = true;
            return _reuseBuilder;
          }
          
          public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input) {
            return MergeFrom(input, null);
          }
          
          public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input, pb::IMessageLite target) {
            if(!(target is ExtensionRange)) {throw new System.Exception("Target is error Type or Null");}
            __result = target as ExtensionRange;
            uint tag;
            string field_name;
            while (input.ReadTag(out tag, out field_name)) {
              if(tag == 0 && field_name != null) {
                int field_ordinal = global::System.Array.BinarySearch(_extensionRangeFieldNames, field_name, global::System.StringComparer.Ordinal);
                if(field_ordinal >= 0)
                  tag = _extensionRangeFieldTags[field_ordinal];
                else {
                  ParseUnknownField(input, tag, field_name);
                  continue;
                }
              }
              switch (tag) {
                case 0: {
                  throw pb::InvalidProtocolBufferException.InvalidTag();
                }
                default: {
                  if (pb::WireFormat.IsEndGroupTag(tag)) {
                    return this;
                  }
                  ParseUnknownField(input, tag, field_name);
                  break;
                }
                case 8: {
                  __result.hasstart = input.ReadInt32(ref __result.start_);
                  break;
                }
                case 16: {
                  __result.hasend = input.ReadInt32(ref __result.end_);
                  break;
                }
              }
            }
            
            return this;
          }
          
          
          
        }
      }
      
    }
    #endregion
    
    public const int nameFieldNumber = 1;
    private bool hasname;
    private string name_ = "";
    public bool Hasname {
      get { return hasname; }
    }
    public string name {
      get { return name_; }
      set { hasname = true; name_ = value;}
    }
    
    public const int fieldFieldNumber = 2;
    private scg::List<global::Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto> field_ = new scg::List<global::Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto>();
    public scg::List<global::Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto> field {
      get { return field_; }
    }
    public int fieldCount {
      get { return field_.Count; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto Getfield(int index) {
      return field_[index];
    }
    
    public const int extensionFieldNumber = 6;
    private scg::List<global::Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto> extension_ = new scg::List<global::Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto>();
    public scg::List<global::Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto> extension {
      get { return extension_; }
    }
    public int extensionCount {
      get { return extension_.Count; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto Getextension(int index) {
      return extension_[index];
    }
    
    public const int nested_typeFieldNumber = 3;
    private scg::List<global::Google.ProtocolBuffers.DescriptorProtos.DescriptorProto> nestedType_ = new scg::List<global::Google.ProtocolBuffers.DescriptorProtos.DescriptorProto>();
    public scg::List<global::Google.ProtocolBuffers.DescriptorProtos.DescriptorProto> nested_type {
      get { return nestedType_; }
    }
    public int nested_typeCount {
      get { return nestedType_.Count; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.DescriptorProto Getnested_type(int index) {
      return nestedType_[index];
    }
    
    public const int enum_typeFieldNumber = 4;
    private scg::List<global::Google.ProtocolBuffers.DescriptorProtos.EnumDescriptorProto> enumType_ = new scg::List<global::Google.ProtocolBuffers.DescriptorProtos.EnumDescriptorProto>();
    public scg::List<global::Google.ProtocolBuffers.DescriptorProtos.EnumDescriptorProto> enum_type {
      get { return enumType_; }
    }
    public int enum_typeCount {
      get { return enumType_.Count; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.EnumDescriptorProto Getenum_type(int index) {
      return enumType_[index];
    }
    
    public const int extension_rangeFieldNumber = 5;
    private scg::List<global::Google.ProtocolBuffers.DescriptorProtos.DescriptorProto.Types.ExtensionRange> extensionRange_ = new scg::List<global::Google.ProtocolBuffers.DescriptorProtos.DescriptorProto.Types.ExtensionRange>();
    public scg::List<global::Google.ProtocolBuffers.DescriptorProtos.DescriptorProto.Types.ExtensionRange> extension_range {
      get { return extensionRange_; }
    }
    public int extension_rangeCount {
      get { return extensionRange_.Count; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.DescriptorProto.Types.ExtensionRange Getextension_range(int index) {
      return extensionRange_[index];
    }
    
    public const int optionsFieldNumber = 7;
    private bool hasoptions;
    private global::Google.ProtocolBuffers.DescriptorProtos.MessageOptions options_;
    public bool Hasoptions {
      get { return hasoptions; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.MessageOptions options {
      get { return options_; }
      set { hasoptions = value != null ? true : false; options_ = value;}
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto element in field) {
          if (!element.IsInitialized) return false;
        }
        foreach (global::Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto element in extension) {
          if (!element.IsInitialized) return false;
        }
        foreach (global::Google.ProtocolBuffers.DescriptorProtos.DescriptorProto element in nested_type) {
          if (!element.IsInitialized) return false;
        }
        foreach (global::Google.ProtocolBuffers.DescriptorProtos.EnumDescriptorProto element in enum_type) {
          if (!element.IsInitialized) return false;
        }
        if (Hasoptions) {
          if (!options.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _descriptorProtoFieldNames;
      if (hasname) {
        output.WriteString(1, field_names[4], name);
      }
      if (field_.Count > 0) {
        output.WriteMessageArray(2, field_names[3], field_);
      }
      if (nestedType_.Count > 0) {
        output.WriteMessageArray(3, field_names[5], nestedType_);
      }
      if (enumType_.Count > 0) {
        output.WriteMessageArray(4, field_names[0], enumType_);
      }
      if (extensionRange_.Count > 0) {
        output.WriteMessageArray(5, field_names[2], extensionRange_);
      }
      if (extension_.Count > 0) {
        output.WriteMessageArray(6, field_names[1], extension_);
      }
      if (hasoptions) {
        output.WriteMessage(7, field_names[6], options);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasname) {
        size += pb::CodedOutputStream.ComputeStringSize(1, name);
      }
      foreach (global::Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto element in field) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, element);
      }
      foreach (global::Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto element in extension) {
        size += pb::CodedOutputStream.ComputeMessageSize(6, element);
      }
      foreach (global::Google.ProtocolBuffers.DescriptorProtos.DescriptorProto element in nested_type) {
        size += pb::CodedOutputStream.ComputeMessageSize(3, element);
      }
      foreach (global::Google.ProtocolBuffers.DescriptorProtos.EnumDescriptorProto element in enum_type) {
        size += pb::CodedOutputStream.ComputeMessageSize(4, element);
      }
      foreach (global::Google.ProtocolBuffers.DescriptorProtos.DescriptorProto.Types.ExtensionRange element in extension_range) {
        size += pb::CodedOutputStream.ComputeMessageSize(5, element);
      }
      if (hasoptions) {
        size += pb::CodedOutputStream.ComputeMessageSize(7, options);
      }
      memoizedSerializedSize = size;
      return size;
    }
    public override void Reset(bool recursive = true, bool reuse = false)
    {
      name_ = "";
      hasname = false;
     if(recursive) for (int i = 0; i <field_.Count; i++) field_[i].Reset(recursive, reuse);
      field_.Clear();
     if(recursive) for (int i = 0; i <nestedType_.Count; i++) nestedType_[i].Reset(recursive, reuse);
      nestedType_.Clear();
     if(recursive) for (int i = 0; i <enumType_.Count; i++) enumType_[i].Reset(recursive, reuse);
      enumType_.Clear();
     if(recursive) for (int i = 0; i <extensionRange_.Count; i++) extensionRange_[i].Reset(recursive, reuse);
      extensionRange_.Clear();
     if(recursive) for (int i = 0; i <extension_.Count; i++) extension_[i].Reset(recursive, reuse);
      extension_.Clear();
      hasoptions = false;
     if(recursive && options_ != null) options_.Reset(recursive, reuse);
      options_ = null;
      memoizedSerializedSize = -1;
      base.Reset(recursive, reuse);
    }
    public static Builder CreateBuilder() { return new Builder(); }
    public override pb::IBuilderLite ToBuilder() { return CreateBuilder(this); }
    public override pb::IBuilderLite CreateBuilderForType() { if (IsReused) return Builder.GetReuseBuilder(); else return new Builder(); }
    public static Builder CreateBuilder(DescriptorProto prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite {
      protected override pb::IBuilderLite ThisBuilder {
        get { return this; }
      }
      public Builder() {
        resultIsReadOnly = true;
      }
      internal Builder(DescriptorProto cloneFrom) {
        __result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private DescriptorProto __result;
      
      private static Builder _reuseBuilder;
      
      private DescriptorProto PrepareBuilder() {
        if (resultIsReadOnly) {
          __result = new DescriptorProto();
          resultIsReadOnly = false;
        }
        return __result;
      }
      
      public override bool IsInitialized {
        get { return __result.IsInitialized; }
      }
      
      protected override pb::GeneratedMessageLite MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override pb::IBuilderLite Clear() {
        resultIsReadOnly = true;
        return this;
      }
      
      public override pb::IMessageLite BuildPartial() {
        if (resultIsReadOnly) {
          return __result;
        }
        resultIsReadOnly = true;
        return __result;
      }
      
      public override pb::IMessageLite BuildEmpty(){
        DescriptorProto message = new DescriptorProto();
        message.IsReused = IsReuseMode;
        return message;
      }
      
      public static DescriptorProto.Builder GetReuseBuilder(){
        if (_reuseBuilder == null) _reuseBuilder = new Builder();
        _reuseBuilder.IsReuseMode = true;
        return _reuseBuilder;
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, null);
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input, pb::IMessageLite target) {
        if(!(target is DescriptorProto)) {throw new System.Exception("Target is error Type or Null");}
        __result = target as DescriptorProto;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_descriptorProtoFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _descriptorProtoFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, tag, field_name);
              break;
            }
            case 10: {
              __result.hasname = input.ReadString(ref __result.name_);
              break;
            }
            case 18: {
              if (IsReuseMode) input.ReadMessageArrayReuse(tag, field_name, __result.field_, global::Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto.Builder.GetReuseBuilder());
              break;
            }
            case 26: {
              if (IsReuseMode) input.ReadMessageArrayReuse(tag, field_name, __result.nestedType_, global::Google.ProtocolBuffers.DescriptorProtos.DescriptorProto.Builder.GetReuseBuilder());
              break;
            }
            case 34: {
              if (IsReuseMode) input.ReadMessageArrayReuse(tag, field_name, __result.enumType_, global::Google.ProtocolBuffers.DescriptorProtos.EnumDescriptorProto.Builder.GetReuseBuilder());
              break;
            }
            case 42: {
              if (IsReuseMode) input.ReadMessageArrayReuse(tag, field_name, __result.extensionRange_, global::Google.ProtocolBuffers.DescriptorProtos.DescriptorProto.Types.ExtensionRange.Builder.GetReuseBuilder());
              break;
            }
            case 50: {
              if (IsReuseMode) input.ReadMessageArrayReuse(tag, field_name, __result.extension_, global::Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto.Builder.GetReuseBuilder());
              break;
            }
            case 58: {
              if (IsReuseMode) __result.options = input.ReadMessageReuse<global::Google.ProtocolBuffers.DescriptorProtos.MessageOptions>(global::Google.ProtocolBuffers.DescriptorProtos.MessageOptions.Builder.GetReuseBuilder()) as global::Google.ProtocolBuffers.DescriptorProtos.MessageOptions;
              break;
            }
          }
        }
        
        return this;
      }
      
      
      
      
      
      
      
      
    }
  }
  
  public sealed partial class FieldDescriptorProto : pb::GeneratedMessageLite {
    public FieldDescriptorProto() { }
    private static readonly string[] _fieldDescriptorProtoFieldNames = new string[] { "default_value", "extendee", "label", "name", "number", "options", "type", "type_name" };
    private static readonly scg::List<uint> _fieldDescriptorProtoFieldTags = new scg::List<uint> { 58, 18, 32, 10, 24, 66, 40, 50 };
    
    
    #region Nested types
    public static partial class Types {
      public enum Type {
        TYPE_DOUBLE = 1,
        TYPE_FLOAT = 2,
        TYPE_INT64 = 3,
        TYPE_UINT64 = 4,
        TYPE_INT32 = 5,
        TYPE_FIXED64 = 6,
        TYPE_FIXED32 = 7,
        TYPE_BOOL = 8,
        TYPE_STRING = 9,
        TYPE_GROUP = 10,
        TYPE_MESSAGE = 11,
        TYPE_BYTES = 12,
        TYPE_UINT32 = 13,
        TYPE_ENUM = 14,
        TYPE_SFIXED32 = 15,
        TYPE_SFIXED64 = 16,
        TYPE_SINT32 = 17,
        TYPE_SINT64 = 18,
      }
      
      public enum Label {
        LABEL_OPTIONAL = 1,
        LABEL_REQUIRED = 2,
        LABEL_REPEATED = 3,
      }
      
    }
    #endregion
    
    public const int nameFieldNumber = 1;
    private bool hasname;
    private string name_ = "";
    public bool Hasname {
      get { return hasname; }
    }
    public string name {
      get { return name_; }
      set { hasname = true; name_ = value;}
    }
    
    public const int numberFieldNumber = 3;
    private bool hasnumber;
    private int number_;
    public bool Hasnumber {
      get { return hasnumber; }
    }
    public int number {
      get { return number_; }
      set { hasnumber = true; number_ = value;}
    }
    
    public const int labelFieldNumber = 4;
    private bool haslabel;
    private global::Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto.Types.Label label_ = global::Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto.Types.Label.LABEL_OPTIONAL;
    public bool Haslabel {
      get { return haslabel; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto.Types.Label label {
      get { return label_; }
      set { haslabel = true; label_ = value;}
    }
    
    public const int typeFieldNumber = 5;
    private bool hastype;
    private global::Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto.Types.Type type_ = global::Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto.Types.Type.TYPE_DOUBLE;
    public bool Hastype {
      get { return hastype; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto.Types.Type type {
      get { return type_; }
      set { hastype = true; type_ = value;}
    }
    
    public const int type_nameFieldNumber = 6;
    private bool hastype_name;
    private string typeName_ = "";
    public bool Hastype_name {
      get { return hastype_name; }
    }
    public string type_name {
      get { return typeName_; }
      set { hastype_name = true; typeName_ = value;}
    }
    
    public const int extendeeFieldNumber = 2;
    private bool hasextendee;
    private string extendee_ = "";
    public bool Hasextendee {
      get { return hasextendee; }
    }
    public string extendee {
      get { return extendee_; }
      set { hasextendee = true; extendee_ = value;}
    }
    
    public const int default_valueFieldNumber = 7;
    private bool hasdefault_value;
    private string defaultValue_ = "";
    public bool Hasdefault_value {
      get { return hasdefault_value; }
    }
    public string default_value {
      get { return defaultValue_; }
      set { hasdefault_value = true; defaultValue_ = value;}
    }
    
    public const int optionsFieldNumber = 8;
    private bool hasoptions;
    private global::Google.ProtocolBuffers.DescriptorProtos.FieldOptions options_;
    public bool Hasoptions {
      get { return hasoptions; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.FieldOptions options {
      get { return options_; }
      set { hasoptions = value != null ? true : false; options_ = value;}
    }
    
    public override bool IsInitialized {
      get {
        if (Hasoptions) {
          if (!options.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _fieldDescriptorProtoFieldNames;
      if (hasname) {
        output.WriteString(1, field_names[3], name);
      }
      if (hasextendee) {
        output.WriteString(2, field_names[1], extendee);
      }
      if (hasnumber) {
        output.WriteInt32(3, field_names[4], number);
      }
      if (haslabel) {
        output.WriteEnum(4, field_names[2], (int) label, label);
      }
      if (hastype) {
        output.WriteEnum(5, field_names[6], (int) type, type);
      }
      if (hastype_name) {
        output.WriteString(6, field_names[7], type_name);
      }
      if (hasdefault_value) {
        output.WriteString(7, field_names[0], default_value);
      }
      if (hasoptions) {
        output.WriteMessage(8, field_names[5], options);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasname) {
        size += pb::CodedOutputStream.ComputeStringSize(1, name);
      }
      if (hasnumber) {
        size += pb::CodedOutputStream.ComputeInt32Size(3, number);
      }
      if (haslabel) {
        size += pb::CodedOutputStream.ComputeEnumSize(4, (int) label);
      }
      if (hastype) {
        size += pb::CodedOutputStream.ComputeEnumSize(5, (int) type);
      }
      if (hastype_name) {
        size += pb::CodedOutputStream.ComputeStringSize(6, type_name);
      }
      if (hasextendee) {
        size += pb::CodedOutputStream.ComputeStringSize(2, extendee);
      }
      if (hasdefault_value) {
        size += pb::CodedOutputStream.ComputeStringSize(7, default_value);
      }
      if (hasoptions) {
        size += pb::CodedOutputStream.ComputeMessageSize(8, options);
      }
      memoizedSerializedSize = size;
      return size;
    }
    public override void Reset(bool recursive = true, bool reuse = false)
    {
      name_ = "";
      hasname = false;
      extendee_ = "";
      hasextendee = false;
      number_ = 0;
      hasnumber = false;
      label_ = global::Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto.Types.Label.LABEL_OPTIONAL;
      haslabel = false;
      type_ = global::Google.ProtocolBuffers.DescriptorProtos.FieldDescriptorProto.Types.Type.TYPE_DOUBLE;
      hastype = false;
      typeName_ = "";
      hastype_name = false;
      defaultValue_ = "";
      hasdefault_value = false;
      hasoptions = false;
     if(recursive && options_ != null) options_.Reset(recursive, reuse);
      options_ = null;
      memoizedSerializedSize = -1;
      base.Reset(recursive, reuse);
    }
    public static Builder CreateBuilder() { return new Builder(); }
    public override pb::IBuilderLite ToBuilder() { return CreateBuilder(this); }
    public override pb::IBuilderLite CreateBuilderForType() { if (IsReused) return Builder.GetReuseBuilder(); else return new Builder(); }
    public static Builder CreateBuilder(FieldDescriptorProto prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite {
      protected override pb::IBuilderLite ThisBuilder {
        get { return this; }
      }
      public Builder() {
        resultIsReadOnly = true;
      }
      internal Builder(FieldDescriptorProto cloneFrom) {
        __result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private FieldDescriptorProto __result;
      
      private static Builder _reuseBuilder;
      
      private FieldDescriptorProto PrepareBuilder() {
        if (resultIsReadOnly) {
          __result = new FieldDescriptorProto();
          resultIsReadOnly = false;
        }
        return __result;
      }
      
      public override bool IsInitialized {
        get { return __result.IsInitialized; }
      }
      
      protected override pb::GeneratedMessageLite MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override pb::IBuilderLite Clear() {
        resultIsReadOnly = true;
        return this;
      }
      
      public override pb::IMessageLite BuildPartial() {
        if (resultIsReadOnly) {
          return __result;
        }
        resultIsReadOnly = true;
        return __result;
      }
      
      public override pb::IMessageLite BuildEmpty(){
        FieldDescriptorProto message = new FieldDescriptorProto();
        message.IsReused = IsReuseMode;
        return message;
      }
      
      public static FieldDescriptorProto.Builder GetReuseBuilder(){
        if (_reuseBuilder == null) _reuseBuilder = new Builder();
        _reuseBuilder.IsReuseMode = true;
        return _reuseBuilder;
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, null);
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input, pb::IMessageLite target) {
        if(!(target is FieldDescriptorProto)) {throw new System.Exception("Target is error Type or Null");}
        __result = target as FieldDescriptorProto;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_fieldDescriptorProtoFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _fieldDescriptorProtoFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, tag, field_name);
              break;
            }
            case 10: {
              __result.hasname = input.ReadString(ref __result.name_);
              break;
            }
            case 18: {
              __result.hasextendee = input.ReadString(ref __result.extendee_);
              break;
            }
            case 24: {
              __result.hasnumber = input.ReadInt32(ref __result.number_);
              break;
            }
            case 32: {
              object unknown;
              if(input.ReadEnum(ref __result.label_, out unknown)) {
                __result.haslabel = true;
              } else if(unknown is int) {
              }
              break;
            }
            case 40: {
              object unknown;
              if(input.ReadEnum(ref __result.type_, out unknown)) {
                __result.hastype = true;
              } else if(unknown is int) {
              }
              break;
            }
            case 50: {
              __result.hastype_name = input.ReadString(ref __result.typeName_);
              break;
            }
            case 58: {
              __result.hasdefault_value = input.ReadString(ref __result.defaultValue_);
              break;
            }
            case 66: {
              if (IsReuseMode) __result.options = input.ReadMessageReuse<global::Google.ProtocolBuffers.DescriptorProtos.FieldOptions>(global::Google.ProtocolBuffers.DescriptorProtos.FieldOptions.Builder.GetReuseBuilder()) as global::Google.ProtocolBuffers.DescriptorProtos.FieldOptions;
              break;
            }
          }
        }
        
        return this;
      }
      
      
      
      
      
      
      
      
      
    }
  }
  
  public sealed partial class EnumDescriptorProto : pb::GeneratedMessageLite {
    public EnumDescriptorProto() { }
    private static readonly string[] _enumDescriptorProtoFieldNames = new string[] { "name", "options", "value" };
    private static readonly scg::List<uint> _enumDescriptorProtoFieldTags = new scg::List<uint> { 10, 26, 18 };
    
    
    public const int nameFieldNumber = 1;
    private bool hasname;
    private string name_ = "";
    public bool Hasname {
      get { return hasname; }
    }
    public string name {
      get { return name_; }
      set { hasname = true; name_ = value;}
    }
    
    public const int valueFieldNumber = 2;
    private scg::List<global::Google.ProtocolBuffers.DescriptorProtos.EnumValueDescriptorProto> value_ = new scg::List<global::Google.ProtocolBuffers.DescriptorProtos.EnumValueDescriptorProto>();
    public scg::List<global::Google.ProtocolBuffers.DescriptorProtos.EnumValueDescriptorProto> value {
      get { return value_; }
    }
    public int valueCount {
      get { return value_.Count; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.EnumValueDescriptorProto Getvalue(int index) {
      return value_[index];
    }
    
    public const int optionsFieldNumber = 3;
    private bool hasoptions;
    private global::Google.ProtocolBuffers.DescriptorProtos.EnumOptions options_;
    public bool Hasoptions {
      get { return hasoptions; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.EnumOptions options {
      get { return options_; }
      set { hasoptions = value != null ? true : false; options_ = value;}
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::Google.ProtocolBuffers.DescriptorProtos.EnumValueDescriptorProto element in value) {
          if (!element.IsInitialized) return false;
        }
        if (Hasoptions) {
          if (!options.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _enumDescriptorProtoFieldNames;
      if (hasname) {
        output.WriteString(1, field_names[0], name);
      }
      if (value_.Count > 0) {
        output.WriteMessageArray(2, field_names[2], value_);
      }
      if (hasoptions) {
        output.WriteMessage(3, field_names[1], options);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasname) {
        size += pb::CodedOutputStream.ComputeStringSize(1, name);
      }
      foreach (global::Google.ProtocolBuffers.DescriptorProtos.EnumValueDescriptorProto element in value) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, element);
      }
      if (hasoptions) {
        size += pb::CodedOutputStream.ComputeMessageSize(3, options);
      }
      memoizedSerializedSize = size;
      return size;
    }
    public override void Reset(bool recursive = true, bool reuse = false)
    {
      name_ = "";
      hasname = false;
     if(recursive) for (int i = 0; i <value_.Count; i++) value_[i].Reset(recursive, reuse);
      value_.Clear();
      hasoptions = false;
     if(recursive && options_ != null) options_.Reset(recursive, reuse);
      options_ = null;
      memoizedSerializedSize = -1;
      base.Reset(recursive, reuse);
    }
    public static Builder CreateBuilder() { return new Builder(); }
    public override pb::IBuilderLite ToBuilder() { return CreateBuilder(this); }
    public override pb::IBuilderLite CreateBuilderForType() { if (IsReused) return Builder.GetReuseBuilder(); else return new Builder(); }
    public static Builder CreateBuilder(EnumDescriptorProto prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite {
      protected override pb::IBuilderLite ThisBuilder {
        get { return this; }
      }
      public Builder() {
        resultIsReadOnly = true;
      }
      internal Builder(EnumDescriptorProto cloneFrom) {
        __result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private EnumDescriptorProto __result;
      
      private static Builder _reuseBuilder;
      
      private EnumDescriptorProto PrepareBuilder() {
        if (resultIsReadOnly) {
          __result = new EnumDescriptorProto();
          resultIsReadOnly = false;
        }
        return __result;
      }
      
      public override bool IsInitialized {
        get { return __result.IsInitialized; }
      }
      
      protected override pb::GeneratedMessageLite MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override pb::IBuilderLite Clear() {
        resultIsReadOnly = true;
        return this;
      }
      
      public override pb::IMessageLite BuildPartial() {
        if (resultIsReadOnly) {
          return __result;
        }
        resultIsReadOnly = true;
        return __result;
      }
      
      public override pb::IMessageLite BuildEmpty(){
        EnumDescriptorProto message = new EnumDescriptorProto();
        message.IsReused = IsReuseMode;
        return message;
      }
      
      public static EnumDescriptorProto.Builder GetReuseBuilder(){
        if (_reuseBuilder == null) _reuseBuilder = new Builder();
        _reuseBuilder.IsReuseMode = true;
        return _reuseBuilder;
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, null);
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input, pb::IMessageLite target) {
        if(!(target is EnumDescriptorProto)) {throw new System.Exception("Target is error Type or Null");}
        __result = target as EnumDescriptorProto;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_enumDescriptorProtoFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _enumDescriptorProtoFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, tag, field_name);
              break;
            }
            case 10: {
              __result.hasname = input.ReadString(ref __result.name_);
              break;
            }
            case 18: {
              if (IsReuseMode) input.ReadMessageArrayReuse(tag, field_name, __result.value_, global::Google.ProtocolBuffers.DescriptorProtos.EnumValueDescriptorProto.Builder.GetReuseBuilder());
              break;
            }
            case 26: {
              if (IsReuseMode) __result.options = input.ReadMessageReuse<global::Google.ProtocolBuffers.DescriptorProtos.EnumOptions>(global::Google.ProtocolBuffers.DescriptorProtos.EnumOptions.Builder.GetReuseBuilder()) as global::Google.ProtocolBuffers.DescriptorProtos.EnumOptions;
              break;
            }
          }
        }
        
        return this;
      }
      
      
      
      
    }
  }
  
  public sealed partial class EnumValueDescriptorProto : pb::GeneratedMessageLite {
    public EnumValueDescriptorProto() { }
    private static readonly string[] _enumValueDescriptorProtoFieldNames = new string[] { "name", "number", "options" };
    private static readonly scg::List<uint> _enumValueDescriptorProtoFieldTags = new scg::List<uint> { 10, 16, 26 };
    
    
    public const int nameFieldNumber = 1;
    private bool hasname;
    private string name_ = "";
    public bool Hasname {
      get { return hasname; }
    }
    public string name {
      get { return name_; }
      set { hasname = true; name_ = value;}
    }
    
    public const int numberFieldNumber = 2;
    private bool hasnumber;
    private int number_;
    public bool Hasnumber {
      get { return hasnumber; }
    }
    public int number {
      get { return number_; }
      set { hasnumber = true; number_ = value;}
    }
    
    public const int optionsFieldNumber = 3;
    private bool hasoptions;
    private global::Google.ProtocolBuffers.DescriptorProtos.EnumValueOptions options_;
    public bool Hasoptions {
      get { return hasoptions; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.EnumValueOptions options {
      get { return options_; }
      set { hasoptions = value != null ? true : false; options_ = value;}
    }
    
    public override bool IsInitialized {
      get {
        if (Hasoptions) {
          if (!options.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _enumValueDescriptorProtoFieldNames;
      if (hasname) {
        output.WriteString(1, field_names[0], name);
      }
      if (hasnumber) {
        output.WriteInt32(2, field_names[1], number);
      }
      if (hasoptions) {
        output.WriteMessage(3, field_names[2], options);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasname) {
        size += pb::CodedOutputStream.ComputeStringSize(1, name);
      }
      if (hasnumber) {
        size += pb::CodedOutputStream.ComputeInt32Size(2, number);
      }
      if (hasoptions) {
        size += pb::CodedOutputStream.ComputeMessageSize(3, options);
      }
      memoizedSerializedSize = size;
      return size;
    }
    public override void Reset(bool recursive = true, bool reuse = false)
    {
      name_ = "";
      hasname = false;
      number_ = 0;
      hasnumber = false;
      hasoptions = false;
     if(recursive && options_ != null) options_.Reset(recursive, reuse);
      options_ = null;
      memoizedSerializedSize = -1;
      base.Reset(recursive, reuse);
    }
    public static Builder CreateBuilder() { return new Builder(); }
    public override pb::IBuilderLite ToBuilder() { return CreateBuilder(this); }
    public override pb::IBuilderLite CreateBuilderForType() { if (IsReused) return Builder.GetReuseBuilder(); else return new Builder(); }
    public static Builder CreateBuilder(EnumValueDescriptorProto prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite {
      protected override pb::IBuilderLite ThisBuilder {
        get { return this; }
      }
      public Builder() {
        resultIsReadOnly = true;
      }
      internal Builder(EnumValueDescriptorProto cloneFrom) {
        __result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private EnumValueDescriptorProto __result;
      
      private static Builder _reuseBuilder;
      
      private EnumValueDescriptorProto PrepareBuilder() {
        if (resultIsReadOnly) {
          __result = new EnumValueDescriptorProto();
          resultIsReadOnly = false;
        }
        return __result;
      }
      
      public override bool IsInitialized {
        get { return __result.IsInitialized; }
      }
      
      protected override pb::GeneratedMessageLite MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override pb::IBuilderLite Clear() {
        resultIsReadOnly = true;
        return this;
      }
      
      public override pb::IMessageLite BuildPartial() {
        if (resultIsReadOnly) {
          return __result;
        }
        resultIsReadOnly = true;
        return __result;
      }
      
      public override pb::IMessageLite BuildEmpty(){
        EnumValueDescriptorProto message = new EnumValueDescriptorProto();
        message.IsReused = IsReuseMode;
        return message;
      }
      
      public static EnumValueDescriptorProto.Builder GetReuseBuilder(){
        if (_reuseBuilder == null) _reuseBuilder = new Builder();
        _reuseBuilder.IsReuseMode = true;
        return _reuseBuilder;
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, null);
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input, pb::IMessageLite target) {
        if(!(target is EnumValueDescriptorProto)) {throw new System.Exception("Target is error Type or Null");}
        __result = target as EnumValueDescriptorProto;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_enumValueDescriptorProtoFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _enumValueDescriptorProtoFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, tag, field_name);
              break;
            }
            case 10: {
              __result.hasname = input.ReadString(ref __result.name_);
              break;
            }
            case 16: {
              __result.hasnumber = input.ReadInt32(ref __result.number_);
              break;
            }
            case 26: {
              if (IsReuseMode) __result.options = input.ReadMessageReuse<global::Google.ProtocolBuffers.DescriptorProtos.EnumValueOptions>(global::Google.ProtocolBuffers.DescriptorProtos.EnumValueOptions.Builder.GetReuseBuilder()) as global::Google.ProtocolBuffers.DescriptorProtos.EnumValueOptions;
              break;
            }
          }
        }
        
        return this;
      }
      
      
      
      
    }
  }
  
  public sealed partial class ServiceDescriptorProto : pb::GeneratedMessageLite {
    public ServiceDescriptorProto() { }
    private static readonly string[] _serviceDescriptorProtoFieldNames = new string[] { "method", "name", "options" };
    private static readonly scg::List<uint> _serviceDescriptorProtoFieldTags = new scg::List<uint> { 18, 10, 26 };
    
    
    public const int nameFieldNumber = 1;
    private bool hasname;
    private string name_ = "";
    public bool Hasname {
      get { return hasname; }
    }
    public string name {
      get { return name_; }
      set { hasname = true; name_ = value;}
    }
    
    public const int methodFieldNumber = 2;
    private scg::List<global::Google.ProtocolBuffers.DescriptorProtos.MethodDescriptorProto> method_ = new scg::List<global::Google.ProtocolBuffers.DescriptorProtos.MethodDescriptorProto>();
    public scg::List<global::Google.ProtocolBuffers.DescriptorProtos.MethodDescriptorProto> method {
      get { return method_; }
    }
    public int methodCount {
      get { return method_.Count; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.MethodDescriptorProto Getmethod(int index) {
      return method_[index];
    }
    
    public const int optionsFieldNumber = 3;
    private bool hasoptions;
    private global::Google.ProtocolBuffers.DescriptorProtos.ServiceOptions options_;
    public bool Hasoptions {
      get { return hasoptions; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.ServiceOptions options {
      get { return options_; }
      set { hasoptions = value != null ? true : false; options_ = value;}
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::Google.ProtocolBuffers.DescriptorProtos.MethodDescriptorProto element in method) {
          if (!element.IsInitialized) return false;
        }
        if (Hasoptions) {
          if (!options.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _serviceDescriptorProtoFieldNames;
      if (hasname) {
        output.WriteString(1, field_names[1], name);
      }
      if (method_.Count > 0) {
        output.WriteMessageArray(2, field_names[0], method_);
      }
      if (hasoptions) {
        output.WriteMessage(3, field_names[2], options);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasname) {
        size += pb::CodedOutputStream.ComputeStringSize(1, name);
      }
      foreach (global::Google.ProtocolBuffers.DescriptorProtos.MethodDescriptorProto element in method) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, element);
      }
      if (hasoptions) {
        size += pb::CodedOutputStream.ComputeMessageSize(3, options);
      }
      memoizedSerializedSize = size;
      return size;
    }
    public override void Reset(bool recursive = true, bool reuse = false)
    {
      name_ = "";
      hasname = false;
     if(recursive) for (int i = 0; i <method_.Count; i++) method_[i].Reset(recursive, reuse);
      method_.Clear();
      hasoptions = false;
     if(recursive && options_ != null) options_.Reset(recursive, reuse);
      options_ = null;
      memoizedSerializedSize = -1;
      base.Reset(recursive, reuse);
    }
    public static Builder CreateBuilder() { return new Builder(); }
    public override pb::IBuilderLite ToBuilder() { return CreateBuilder(this); }
    public override pb::IBuilderLite CreateBuilderForType() { if (IsReused) return Builder.GetReuseBuilder(); else return new Builder(); }
    public static Builder CreateBuilder(ServiceDescriptorProto prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite {
      protected override pb::IBuilderLite ThisBuilder {
        get { return this; }
      }
      public Builder() {
        resultIsReadOnly = true;
      }
      internal Builder(ServiceDescriptorProto cloneFrom) {
        __result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ServiceDescriptorProto __result;
      
      private static Builder _reuseBuilder;
      
      private ServiceDescriptorProto PrepareBuilder() {
        if (resultIsReadOnly) {
          __result = new ServiceDescriptorProto();
          resultIsReadOnly = false;
        }
        return __result;
      }
      
      public override bool IsInitialized {
        get { return __result.IsInitialized; }
      }
      
      protected override pb::GeneratedMessageLite MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override pb::IBuilderLite Clear() {
        resultIsReadOnly = true;
        return this;
      }
      
      public override pb::IMessageLite BuildPartial() {
        if (resultIsReadOnly) {
          return __result;
        }
        resultIsReadOnly = true;
        return __result;
      }
      
      public override pb::IMessageLite BuildEmpty(){
        ServiceDescriptorProto message = new ServiceDescriptorProto();
        message.IsReused = IsReuseMode;
        return message;
      }
      
      public static ServiceDescriptorProto.Builder GetReuseBuilder(){
        if (_reuseBuilder == null) _reuseBuilder = new Builder();
        _reuseBuilder.IsReuseMode = true;
        return _reuseBuilder;
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, null);
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input, pb::IMessageLite target) {
        if(!(target is ServiceDescriptorProto)) {throw new System.Exception("Target is error Type or Null");}
        __result = target as ServiceDescriptorProto;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_serviceDescriptorProtoFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _serviceDescriptorProtoFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, tag, field_name);
              break;
            }
            case 10: {
              __result.hasname = input.ReadString(ref __result.name_);
              break;
            }
            case 18: {
              if (IsReuseMode) input.ReadMessageArrayReuse(tag, field_name, __result.method_, global::Google.ProtocolBuffers.DescriptorProtos.MethodDescriptorProto.Builder.GetReuseBuilder());
              break;
            }
            case 26: {
              if (IsReuseMode) __result.options = input.ReadMessageReuse<global::Google.ProtocolBuffers.DescriptorProtos.ServiceOptions>(global::Google.ProtocolBuffers.DescriptorProtos.ServiceOptions.Builder.GetReuseBuilder()) as global::Google.ProtocolBuffers.DescriptorProtos.ServiceOptions;
              break;
            }
          }
        }
        
        return this;
      }
      
      
      
      
    }
  }
  
  public sealed partial class MethodDescriptorProto : pb::GeneratedMessageLite {
    public MethodDescriptorProto() { }
    private static readonly string[] _methodDescriptorProtoFieldNames = new string[] { "input_type", "name", "options", "output_type" };
    private static readonly scg::List<uint> _methodDescriptorProtoFieldTags = new scg::List<uint> { 18, 10, 34, 26 };
    
    
    public const int nameFieldNumber = 1;
    private bool hasname;
    private string name_ = "";
    public bool Hasname {
      get { return hasname; }
    }
    public string name {
      get { return name_; }
      set { hasname = true; name_ = value;}
    }
    
    public const int input_typeFieldNumber = 2;
    private bool hasinput_type;
    private string inputType_ = "";
    public bool Hasinput_type {
      get { return hasinput_type; }
    }
    public string input_type {
      get { return inputType_; }
      set { hasinput_type = true; inputType_ = value;}
    }
    
    public const int output_typeFieldNumber = 3;
    private bool hasoutput_type;
    private string outputType_ = "";
    public bool Hasoutput_type {
      get { return hasoutput_type; }
    }
    public string output_type {
      get { return outputType_; }
      set { hasoutput_type = true; outputType_ = value;}
    }
    
    public const int optionsFieldNumber = 4;
    private bool hasoptions;
    private global::Google.ProtocolBuffers.DescriptorProtos.MethodOptions options_;
    public bool Hasoptions {
      get { return hasoptions; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.MethodOptions options {
      get { return options_; }
      set { hasoptions = value != null ? true : false; options_ = value;}
    }
    
    public override bool IsInitialized {
      get {
        if (Hasoptions) {
          if (!options.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _methodDescriptorProtoFieldNames;
      if (hasname) {
        output.WriteString(1, field_names[1], name);
      }
      if (hasinput_type) {
        output.WriteString(2, field_names[0], input_type);
      }
      if (hasoutput_type) {
        output.WriteString(3, field_names[3], output_type);
      }
      if (hasoptions) {
        output.WriteMessage(4, field_names[2], options);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasname) {
        size += pb::CodedOutputStream.ComputeStringSize(1, name);
      }
      if (hasinput_type) {
        size += pb::CodedOutputStream.ComputeStringSize(2, input_type);
      }
      if (hasoutput_type) {
        size += pb::CodedOutputStream.ComputeStringSize(3, output_type);
      }
      if (hasoptions) {
        size += pb::CodedOutputStream.ComputeMessageSize(4, options);
      }
      memoizedSerializedSize = size;
      return size;
    }
    public override void Reset(bool recursive = true, bool reuse = false)
    {
      name_ = "";
      hasname = false;
      inputType_ = "";
      hasinput_type = false;
      outputType_ = "";
      hasoutput_type = false;
      hasoptions = false;
     if(recursive && options_ != null) options_.Reset(recursive, reuse);
      options_ = null;
      memoizedSerializedSize = -1;
      base.Reset(recursive, reuse);
    }
    public static Builder CreateBuilder() { return new Builder(); }
    public override pb::IBuilderLite ToBuilder() { return CreateBuilder(this); }
    public override pb::IBuilderLite CreateBuilderForType() { if (IsReused) return Builder.GetReuseBuilder(); else return new Builder(); }
    public static Builder CreateBuilder(MethodDescriptorProto prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite {
      protected override pb::IBuilderLite ThisBuilder {
        get { return this; }
      }
      public Builder() {
        resultIsReadOnly = true;
      }
      internal Builder(MethodDescriptorProto cloneFrom) {
        __result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private MethodDescriptorProto __result;
      
      private static Builder _reuseBuilder;
      
      private MethodDescriptorProto PrepareBuilder() {
        if (resultIsReadOnly) {
          __result = new MethodDescriptorProto();
          resultIsReadOnly = false;
        }
        return __result;
      }
      
      public override bool IsInitialized {
        get { return __result.IsInitialized; }
      }
      
      protected override pb::GeneratedMessageLite MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override pb::IBuilderLite Clear() {
        resultIsReadOnly = true;
        return this;
      }
      
      public override pb::IMessageLite BuildPartial() {
        if (resultIsReadOnly) {
          return __result;
        }
        resultIsReadOnly = true;
        return __result;
      }
      
      public override pb::IMessageLite BuildEmpty(){
        MethodDescriptorProto message = new MethodDescriptorProto();
        message.IsReused = IsReuseMode;
        return message;
      }
      
      public static MethodDescriptorProto.Builder GetReuseBuilder(){
        if (_reuseBuilder == null) _reuseBuilder = new Builder();
        _reuseBuilder.IsReuseMode = true;
        return _reuseBuilder;
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, null);
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input, pb::IMessageLite target) {
        if(!(target is MethodDescriptorProto)) {throw new System.Exception("Target is error Type or Null");}
        __result = target as MethodDescriptorProto;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_methodDescriptorProtoFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _methodDescriptorProtoFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, tag, field_name);
              break;
            }
            case 10: {
              __result.hasname = input.ReadString(ref __result.name_);
              break;
            }
            case 18: {
              __result.hasinput_type = input.ReadString(ref __result.inputType_);
              break;
            }
            case 26: {
              __result.hasoutput_type = input.ReadString(ref __result.outputType_);
              break;
            }
            case 34: {
              if (IsReuseMode) __result.options = input.ReadMessageReuse<global::Google.ProtocolBuffers.DescriptorProtos.MethodOptions>(global::Google.ProtocolBuffers.DescriptorProtos.MethodOptions.Builder.GetReuseBuilder()) as global::Google.ProtocolBuffers.DescriptorProtos.MethodOptions;
              break;
            }
          }
        }
        
        return this;
      }
      
      
      
      
      
    }
  }
  
  public sealed partial class FileOptions : pb::ExtendableMessageLite {
    public FileOptions() { }
    private static readonly string[] _fileOptionsFieldNames = new string[] { "cc_generic_services", "go_package", "java_generate_equals_and_hash", "java_generic_services", "java_multiple_files", "java_outer_classname", "java_package", "optimize_for", "py_generic_services", "uninterpreted_option" };
    private static readonly scg::List<uint> _fileOptionsFieldTags = new scg::List<uint> { 128, 90, 160, 136, 80, 66, 10, 72, 144, 7994 };
    
    
    #region Nested types
    public static partial class Types {
      public enum OptimizeMode {
        SPEED = 1,
        CODE_SIZE = 2,
        LITE_RUNTIME = 3,
      }
      
    }
    #endregion
    
    public const int java_packageFieldNumber = 1;
    private bool hasjava_package;
    private string javaPackage_ = "";
    public bool Hasjava_package {
      get { return hasjava_package; }
    }
    public string java_package {
      get { return javaPackage_; }
      set { hasjava_package = true; javaPackage_ = value;}
    }
    
    public const int java_outer_classnameFieldNumber = 8;
    private bool hasjava_outer_classname;
    private string javaOuterClassname_ = "";
    public bool Hasjava_outer_classname {
      get { return hasjava_outer_classname; }
    }
    public string java_outer_classname {
      get { return javaOuterClassname_; }
      set { hasjava_outer_classname = true; javaOuterClassname_ = value;}
    }
    
    public const int java_multiple_filesFieldNumber = 10;
    private bool hasjava_multiple_files;
    private bool javaMultipleFiles_;
    public bool Hasjava_multiple_files {
      get { return hasjava_multiple_files; }
    }
    public bool java_multiple_files {
      get { return javaMultipleFiles_; }
      set { hasjava_multiple_files = true; javaMultipleFiles_ = value;}
    }
    
    public const int java_generate_equals_and_hashFieldNumber = 20;
    private bool hasjava_generate_equals_and_hash;
    private bool javaGenerateEqualsAndHash_;
    public bool Hasjava_generate_equals_and_hash {
      get { return hasjava_generate_equals_and_hash; }
    }
    public bool java_generate_equals_and_hash {
      get { return javaGenerateEqualsAndHash_; }
      set { hasjava_generate_equals_and_hash = true; javaGenerateEqualsAndHash_ = value;}
    }
    
    public const int optimize_forFieldNumber = 9;
    private bool hasoptimize_for;
    private global::Google.ProtocolBuffers.DescriptorProtos.FileOptions.Types.OptimizeMode optimizeFor_ = global::Google.ProtocolBuffers.DescriptorProtos.FileOptions.Types.OptimizeMode.SPEED;
    public bool Hasoptimize_for {
      get { return hasoptimize_for; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.FileOptions.Types.OptimizeMode optimize_for {
      get { return optimizeFor_; }
      set { hasoptimize_for = true; optimizeFor_ = value;}
    }
    
    public const int go_packageFieldNumber = 11;
    private bool hasgo_package;
    private string goPackage_ = "";
    public bool Hasgo_package {
      get { return hasgo_package; }
    }
    public string go_package {
      get { return goPackage_; }
      set { hasgo_package = true; goPackage_ = value;}
    }
    
    public const int cc_generic_servicesFieldNumber = 16;
    private bool hascc_generic_services;
    private bool ccGenericServices_;
    public bool Hascc_generic_services {
      get { return hascc_generic_services; }
    }
    public bool cc_generic_services {
      get { return ccGenericServices_; }
      set { hascc_generic_services = true; ccGenericServices_ = value;}
    }
    
    public const int java_generic_servicesFieldNumber = 17;
    private bool hasjava_generic_services;
    private bool javaGenericServices_;
    public bool Hasjava_generic_services {
      get { return hasjava_generic_services; }
    }
    public bool java_generic_services {
      get { return javaGenericServices_; }
      set { hasjava_generic_services = true; javaGenericServices_ = value;}
    }
    
    public const int py_generic_servicesFieldNumber = 18;
    private bool haspy_generic_services;
    private bool pyGenericServices_;
    public bool Haspy_generic_services {
      get { return haspy_generic_services; }
    }
    public bool py_generic_services {
      get { return pyGenericServices_; }
      set { haspy_generic_services = true; pyGenericServices_ = value;}
    }
    
    public const int uninterpreted_optionFieldNumber = 999;
    private scg::List<global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption> uninterpretedOption_ = new scg::List<global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption>();
    public scg::List<global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption> uninterpreted_option {
      get { return uninterpretedOption_; }
    }
    public int uninterpreted_optionCount {
      get { return uninterpretedOption_.Count; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption Getuninterpreted_option(int index) {
      return uninterpretedOption_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption element in uninterpreted_option) {
          if (!element.IsInitialized) return false;
        }
        if (!ExtensionsAreInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _fileOptionsFieldNames;
      pb::ExtendableMessageLite<FileOptions, FileOptions.Builder>.ExtensionWriter extensionWriter = CreateExtensionWriter(this);
      if (hasjava_package) {
        output.WriteString(1, field_names[6], java_package);
      }
      if (hasjava_outer_classname) {
        output.WriteString(8, field_names[5], java_outer_classname);
      }
      if (hasoptimize_for) {
        output.WriteEnum(9, field_names[7], (int) optimize_for, optimize_for);
      }
      if (hasjava_multiple_files) {
        output.WriteBool(10, field_names[4], java_multiple_files);
      }
      if (hasgo_package) {
        output.WriteString(11, field_names[1], go_package);
      }
      if (hascc_generic_services) {
        output.WriteBool(16, field_names[0], cc_generic_services);
      }
      if (hasjava_generic_services) {
        output.WriteBool(17, field_names[3], java_generic_services);
      }
      if (haspy_generic_services) {
        output.WriteBool(18, field_names[8], py_generic_services);
      }
      if (hasjava_generate_equals_and_hash) {
        output.WriteBool(20, field_names[2], java_generate_equals_and_hash);
      }
      if (uninterpretedOption_.Count > 0) {
        output.WriteMessageArray(999, field_names[9], uninterpretedOption_);
      }
      extensionWriter.WriteUntil(536870912, output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasjava_package) {
        size += pb::CodedOutputStream.ComputeStringSize(1, java_package);
      }
      if (hasjava_outer_classname) {
        size += pb::CodedOutputStream.ComputeStringSize(8, java_outer_classname);
      }
      if (hasjava_multiple_files) {
        size += pb::CodedOutputStream.ComputeBoolSize(10, java_multiple_files);
      }
      if (hasjava_generate_equals_and_hash) {
        size += pb::CodedOutputStream.ComputeBoolSize(20, java_generate_equals_and_hash);
      }
      if (hasoptimize_for) {
        size += pb::CodedOutputStream.ComputeEnumSize(9, (int) optimize_for);
      }
      if (hasgo_package) {
        size += pb::CodedOutputStream.ComputeStringSize(11, go_package);
      }
      if (hascc_generic_services) {
        size += pb::CodedOutputStream.ComputeBoolSize(16, cc_generic_services);
      }
      if (hasjava_generic_services) {
        size += pb::CodedOutputStream.ComputeBoolSize(17, java_generic_services);
      }
      if (haspy_generic_services) {
        size += pb::CodedOutputStream.ComputeBoolSize(18, py_generic_services);
      }
      foreach (global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption element in uninterpreted_option) {
        size += pb::CodedOutputStream.ComputeMessageSize(999, element);
      }
      size += ExtensionsSerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public override void Reset(bool recursive = true, bool reuse = false)
    {
      javaPackage_ = "";
      hasjava_package = false;
      javaOuterClassname_ = "";
      hasjava_outer_classname = false;
      optimizeFor_ = global::Google.ProtocolBuffers.DescriptorProtos.FileOptions.Types.OptimizeMode.SPEED;
      hasoptimize_for = false;
      javaMultipleFiles_ = false;
      hasjava_multiple_files = false;
      goPackage_ = "";
      hasgo_package = false;
      ccGenericServices_ = false;
      hascc_generic_services = false;
      javaGenericServices_ = false;
      hasjava_generic_services = false;
      pyGenericServices_ = false;
      haspy_generic_services = false;
      javaGenerateEqualsAndHash_ = false;
      hasjava_generate_equals_and_hash = false;
     if(recursive) for (int i = 0; i <uninterpretedOption_.Count; i++) uninterpretedOption_[i].Reset(recursive, reuse);
      uninterpretedOption_.Clear();
    看看这个是什么(536870912, output);
      memoizedSerializedSize = -1;
      base.Reset(recursive, reuse);
    }
    public static Builder CreateBuilder() { return new Builder(); }
    public override pb::IBuilderLite ToBuilder() { return CreateBuilder(this); }
    public override pb::IBuilderLite CreateBuilderForType() { if (IsReused) return Builder.GetReuseBuilder(); else return new Builder(); }
    public static Builder CreateBuilder(FileOptions prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::ExtendableBuilderLite {
      protected override pb::IBuilderLite ThisBuilder {
        get { return this; }
      }
      public Builder() {
        resultIsReadOnly = true;
      }
      internal Builder(FileOptions cloneFrom) {
        __result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private FileOptions __result;
      
      private static Builder _reuseBuilder;
      
      private FileOptions PrepareBuilder() {
        if (resultIsReadOnly) {
          __result = new FileOptions();
          resultIsReadOnly = false;
        }
        return __result;
      }
      
      public override bool IsInitialized {
        get { return __result.IsInitialized; }
      }
      
      protected override pb::GeneratedMessageLite MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override pb::IBuilderLite Clear() {
        resultIsReadOnly = true;
        return this;
      }
      
      public override pb::IMessageLite BuildPartial() {
        if (resultIsReadOnly) {
          return __result;
        }
        resultIsReadOnly = true;
        return __result;
      }
      
      public override pb::IMessageLite BuildEmpty(){
        FileOptions message = new FileOptions();
        message.IsReused = IsReuseMode;
        return message;
      }
      
      public static FileOptions.Builder GetReuseBuilder(){
        if (_reuseBuilder == null) _reuseBuilder = new Builder();
        _reuseBuilder.IsReuseMode = true;
        return _reuseBuilder;
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, null);
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input, pb::IMessageLite target) {
        if(!(target is FileOptions)) {throw new System.Exception("Target is error Type or Null");}
        __result = target as FileOptions;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_fileOptionsFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _fileOptionsFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, tag, field_name);
              break;
            }
            case 10: {
              __result.hasjava_package = input.ReadString(ref __result.javaPackage_);
              break;
            }
            case 66: {
              __result.hasjava_outer_classname = input.ReadString(ref __result.javaOuterClassname_);
              break;
            }
            case 72: {
              object unknown;
              if(input.ReadEnum(ref __result.optimizeFor_, out unknown)) {
                __result.hasoptimize_for = true;
              } else if(unknown is int) {
              }
              break;
            }
            case 80: {
              __result.hasjava_multiple_files = input.ReadBool(ref __result.javaMultipleFiles_);
              break;
            }
            case 90: {
              __result.hasgo_package = input.ReadString(ref __result.goPackage_);
              break;
            }
            case 128: {
              __result.hascc_generic_services = input.ReadBool(ref __result.ccGenericServices_);
              break;
            }
            case 136: {
              __result.hasjava_generic_services = input.ReadBool(ref __result.javaGenericServices_);
              break;
            }
            case 144: {
              __result.haspy_generic_services = input.ReadBool(ref __result.pyGenericServices_);
              break;
            }
            case 160: {
              __result.hasjava_generate_equals_and_hash = input.ReadBool(ref __result.javaGenerateEqualsAndHash_);
              break;
            }
            case 7994: {
              if (IsReuseMode) input.ReadMessageArrayReuse(tag, field_name, __result.uninterpretedOption_, global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption.Builder.GetReuseBuilder());
              break;
            }
          }
        }
        
        return this;
      }
      
      
      
      
      
      
      
      
      
      
      
    }
  }
  
  public sealed partial class MessageOptions : pb::ExtendableMessageLite {
    public MessageOptions() { }
    private static readonly string[] _messageOptionsFieldNames = new string[] { "message_set_wire_format", "no_standard_descriptor_accessor", "uninterpreted_option" };
    private static readonly scg::List<uint> _messageOptionsFieldTags = new scg::List<uint> { 8, 16, 7994 };
    
    
    public const int message_set_wire_formatFieldNumber = 1;
    private bool hasmessage_set_wire_format;
    private bool messageSetWireFormat_;
    public bool Hasmessage_set_wire_format {
      get { return hasmessage_set_wire_format; }
    }
    public bool message_set_wire_format {
      get { return messageSetWireFormat_; }
      set { hasmessage_set_wire_format = true; messageSetWireFormat_ = value;}
    }
    
    public const int no_standard_descriptor_accessorFieldNumber = 2;
    private bool hasno_standard_descriptor_accessor;
    private bool noStandardDescriptorAccessor_;
    public bool Hasno_standard_descriptor_accessor {
      get { return hasno_standard_descriptor_accessor; }
    }
    public bool no_standard_descriptor_accessor {
      get { return noStandardDescriptorAccessor_; }
      set { hasno_standard_descriptor_accessor = true; noStandardDescriptorAccessor_ = value;}
    }
    
    public const int uninterpreted_optionFieldNumber = 999;
    private scg::List<global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption> uninterpretedOption_ = new scg::List<global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption>();
    public scg::List<global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption> uninterpreted_option {
      get { return uninterpretedOption_; }
    }
    public int uninterpreted_optionCount {
      get { return uninterpretedOption_.Count; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption Getuninterpreted_option(int index) {
      return uninterpretedOption_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption element in uninterpreted_option) {
          if (!element.IsInitialized) return false;
        }
        if (!ExtensionsAreInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _messageOptionsFieldNames;
      pb::ExtendableMessageLite<MessageOptions, MessageOptions.Builder>.ExtensionWriter extensionWriter = CreateExtensionWriter(this);
      if (hasmessage_set_wire_format) {
        output.WriteBool(1, field_names[0], message_set_wire_format);
      }
      if (hasno_standard_descriptor_accessor) {
        output.WriteBool(2, field_names[1], no_standard_descriptor_accessor);
      }
      if (uninterpretedOption_.Count > 0) {
        output.WriteMessageArray(999, field_names[2], uninterpretedOption_);
      }
      extensionWriter.WriteUntil(536870912, output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasmessage_set_wire_format) {
        size += pb::CodedOutputStream.ComputeBoolSize(1, message_set_wire_format);
      }
      if (hasno_standard_descriptor_accessor) {
        size += pb::CodedOutputStream.ComputeBoolSize(2, no_standard_descriptor_accessor);
      }
      foreach (global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption element in uninterpreted_option) {
        size += pb::CodedOutputStream.ComputeMessageSize(999, element);
      }
      size += ExtensionsSerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public override void Reset(bool recursive = true, bool reuse = false)
    {
      messageSetWireFormat_ = false;
      hasmessage_set_wire_format = false;
      noStandardDescriptorAccessor_ = false;
      hasno_standard_descriptor_accessor = false;
     if(recursive) for (int i = 0; i <uninterpretedOption_.Count; i++) uninterpretedOption_[i].Reset(recursive, reuse);
      uninterpretedOption_.Clear();
    看看这个是什么(536870912, output);
      memoizedSerializedSize = -1;
      base.Reset(recursive, reuse);
    }
    public static Builder CreateBuilder() { return new Builder(); }
    public override pb::IBuilderLite ToBuilder() { return CreateBuilder(this); }
    public override pb::IBuilderLite CreateBuilderForType() { if (IsReused) return Builder.GetReuseBuilder(); else return new Builder(); }
    public static Builder CreateBuilder(MessageOptions prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::ExtendableBuilderLite {
      protected override pb::IBuilderLite ThisBuilder {
        get { return this; }
      }
      public Builder() {
        resultIsReadOnly = true;
      }
      internal Builder(MessageOptions cloneFrom) {
        __result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private MessageOptions __result;
      
      private static Builder _reuseBuilder;
      
      private MessageOptions PrepareBuilder() {
        if (resultIsReadOnly) {
          __result = new MessageOptions();
          resultIsReadOnly = false;
        }
        return __result;
      }
      
      public override bool IsInitialized {
        get { return __result.IsInitialized; }
      }
      
      protected override pb::GeneratedMessageLite MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override pb::IBuilderLite Clear() {
        resultIsReadOnly = true;
        return this;
      }
      
      public override pb::IMessageLite BuildPartial() {
        if (resultIsReadOnly) {
          return __result;
        }
        resultIsReadOnly = true;
        return __result;
      }
      
      public override pb::IMessageLite BuildEmpty(){
        MessageOptions message = new MessageOptions();
        message.IsReused = IsReuseMode;
        return message;
      }
      
      public static MessageOptions.Builder GetReuseBuilder(){
        if (_reuseBuilder == null) _reuseBuilder = new Builder();
        _reuseBuilder.IsReuseMode = true;
        return _reuseBuilder;
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, null);
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input, pb::IMessageLite target) {
        if(!(target is MessageOptions)) {throw new System.Exception("Target is error Type or Null");}
        __result = target as MessageOptions;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_messageOptionsFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _messageOptionsFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, tag, field_name);
              break;
            }
            case 8: {
              __result.hasmessage_set_wire_format = input.ReadBool(ref __result.messageSetWireFormat_);
              break;
            }
            case 16: {
              __result.hasno_standard_descriptor_accessor = input.ReadBool(ref __result.noStandardDescriptorAccessor_);
              break;
            }
            case 7994: {
              if (IsReuseMode) input.ReadMessageArrayReuse(tag, field_name, __result.uninterpretedOption_, global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption.Builder.GetReuseBuilder());
              break;
            }
          }
        }
        
        return this;
      }
      
      
      
      
    }
  }
  
  public sealed partial class FieldOptions : pb::ExtendableMessageLite {
    public FieldOptions() { }
    private static readonly string[] _fieldOptionsFieldNames = new string[] { "ctype", "deprecated", "experimental_map_key", "lazy", "packed", "uninterpreted_option", "weak" };
    private static readonly scg::List<uint> _fieldOptionsFieldTags = new scg::List<uint> { 8, 24, 74, 40, 16, 7994, 80 };
    
    
    #region Nested types
    public static partial class Types {
      public enum CType {
        STRING = 0,
        CORD = 1,
        STRING_PIECE = 2,
      }
      
    }
    #endregion
    
    public const int ctypeFieldNumber = 1;
    private bool hasctype;
    private global::Google.ProtocolBuffers.DescriptorProtos.FieldOptions.Types.CType ctype_ = global::Google.ProtocolBuffers.DescriptorProtos.FieldOptions.Types.CType.STRING;
    public bool Hasctype {
      get { return hasctype; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.FieldOptions.Types.CType ctype {
      get { return ctype_; }
      set { hasctype = true; ctype_ = value;}
    }
    
    public const int packedFieldNumber = 2;
    private bool haspacked;
    private bool packed_;
    public bool Haspacked {
      get { return haspacked; }
    }
    public bool packed {
      get { return packed_; }
      set { haspacked = true; packed_ = value;}
    }
    
    public const int lazyFieldNumber = 5;
    private bool haslazy;
    private bool lazy_;
    public bool Haslazy {
      get { return haslazy; }
    }
    public bool lazy {
      get { return lazy_; }
      set { haslazy = true; lazy_ = value;}
    }
    
    public const int deprecatedFieldNumber = 3;
    private bool hasdeprecated;
    private bool deprecated_;
    public bool Hasdeprecated {
      get { return hasdeprecated; }
    }
    public bool deprecated {
      get { return deprecated_; }
      set { hasdeprecated = true; deprecated_ = value;}
    }
    
    public const int experimental_map_keyFieldNumber = 9;
    private bool hasexperimental_map_key;
    private string experimentalMapKey_ = "";
    public bool Hasexperimental_map_key {
      get { return hasexperimental_map_key; }
    }
    public string experimental_map_key {
      get { return experimentalMapKey_; }
      set { hasexperimental_map_key = true; experimentalMapKey_ = value;}
    }
    
    public const int weakFieldNumber = 10;
    private bool hasweak;
    private bool weak_;
    public bool Hasweak {
      get { return hasweak; }
    }
    public bool weak {
      get { return weak_; }
      set { hasweak = true; weak_ = value;}
    }
    
    public const int uninterpreted_optionFieldNumber = 999;
    private scg::List<global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption> uninterpretedOption_ = new scg::List<global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption>();
    public scg::List<global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption> uninterpreted_option {
      get { return uninterpretedOption_; }
    }
    public int uninterpreted_optionCount {
      get { return uninterpretedOption_.Count; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption Getuninterpreted_option(int index) {
      return uninterpretedOption_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption element in uninterpreted_option) {
          if (!element.IsInitialized) return false;
        }
        if (!ExtensionsAreInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _fieldOptionsFieldNames;
      pb::ExtendableMessageLite<FieldOptions, FieldOptions.Builder>.ExtensionWriter extensionWriter = CreateExtensionWriter(this);
      if (hasctype) {
        output.WriteEnum(1, field_names[0], (int) ctype, ctype);
      }
      if (haspacked) {
        output.WriteBool(2, field_names[4], packed);
      }
      if (hasdeprecated) {
        output.WriteBool(3, field_names[1], deprecated);
      }
      if (haslazy) {
        output.WriteBool(5, field_names[3], lazy);
      }
      if (hasexperimental_map_key) {
        output.WriteString(9, field_names[2], experimental_map_key);
      }
      if (hasweak) {
        output.WriteBool(10, field_names[6], weak);
      }
      if (uninterpretedOption_.Count > 0) {
        output.WriteMessageArray(999, field_names[5], uninterpretedOption_);
      }
      extensionWriter.WriteUntil(536870912, output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasctype) {
        size += pb::CodedOutputStream.ComputeEnumSize(1, (int) ctype);
      }
      if (haspacked) {
        size += pb::CodedOutputStream.ComputeBoolSize(2, packed);
      }
      if (haslazy) {
        size += pb::CodedOutputStream.ComputeBoolSize(5, lazy);
      }
      if (hasdeprecated) {
        size += pb::CodedOutputStream.ComputeBoolSize(3, deprecated);
      }
      if (hasexperimental_map_key) {
        size += pb::CodedOutputStream.ComputeStringSize(9, experimental_map_key);
      }
      if (hasweak) {
        size += pb::CodedOutputStream.ComputeBoolSize(10, weak);
      }
      foreach (global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption element in uninterpreted_option) {
        size += pb::CodedOutputStream.ComputeMessageSize(999, element);
      }
      size += ExtensionsSerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public override void Reset(bool recursive = true, bool reuse = false)
    {
      ctype_ = global::Google.ProtocolBuffers.DescriptorProtos.FieldOptions.Types.CType.STRING;
      hasctype = false;
      packed_ = false;
      haspacked = false;
      deprecated_ = false;
      hasdeprecated = false;
      lazy_ = false;
      haslazy = false;
      experimentalMapKey_ = "";
      hasexperimental_map_key = false;
      weak_ = false;
      hasweak = false;
     if(recursive) for (int i = 0; i <uninterpretedOption_.Count; i++) uninterpretedOption_[i].Reset(recursive, reuse);
      uninterpretedOption_.Clear();
    看看这个是什么(536870912, output);
      memoizedSerializedSize = -1;
      base.Reset(recursive, reuse);
    }
    public static Builder CreateBuilder() { return new Builder(); }
    public override pb::IBuilderLite ToBuilder() { return CreateBuilder(this); }
    public override pb::IBuilderLite CreateBuilderForType() { if (IsReused) return Builder.GetReuseBuilder(); else return new Builder(); }
    public static Builder CreateBuilder(FieldOptions prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::ExtendableBuilderLite {
      protected override pb::IBuilderLite ThisBuilder {
        get { return this; }
      }
      public Builder() {
        resultIsReadOnly = true;
      }
      internal Builder(FieldOptions cloneFrom) {
        __result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private FieldOptions __result;
      
      private static Builder _reuseBuilder;
      
      private FieldOptions PrepareBuilder() {
        if (resultIsReadOnly) {
          __result = new FieldOptions();
          resultIsReadOnly = false;
        }
        return __result;
      }
      
      public override bool IsInitialized {
        get { return __result.IsInitialized; }
      }
      
      protected override pb::GeneratedMessageLite MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override pb::IBuilderLite Clear() {
        resultIsReadOnly = true;
        return this;
      }
      
      public override pb::IMessageLite BuildPartial() {
        if (resultIsReadOnly) {
          return __result;
        }
        resultIsReadOnly = true;
        return __result;
      }
      
      public override pb::IMessageLite BuildEmpty(){
        FieldOptions message = new FieldOptions();
        message.IsReused = IsReuseMode;
        return message;
      }
      
      public static FieldOptions.Builder GetReuseBuilder(){
        if (_reuseBuilder == null) _reuseBuilder = new Builder();
        _reuseBuilder.IsReuseMode = true;
        return _reuseBuilder;
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, null);
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input, pb::IMessageLite target) {
        if(!(target is FieldOptions)) {throw new System.Exception("Target is error Type or Null");}
        __result = target as FieldOptions;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_fieldOptionsFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _fieldOptionsFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref __result.ctype_, out unknown)) {
                __result.hasctype = true;
              } else if(unknown is int) {
              }
              break;
            }
            case 16: {
              __result.haspacked = input.ReadBool(ref __result.packed_);
              break;
            }
            case 24: {
              __result.hasdeprecated = input.ReadBool(ref __result.deprecated_);
              break;
            }
            case 40: {
              __result.haslazy = input.ReadBool(ref __result.lazy_);
              break;
            }
            case 74: {
              __result.hasexperimental_map_key = input.ReadString(ref __result.experimentalMapKey_);
              break;
            }
            case 80: {
              __result.hasweak = input.ReadBool(ref __result.weak_);
              break;
            }
            case 7994: {
              if (IsReuseMode) input.ReadMessageArrayReuse(tag, field_name, __result.uninterpretedOption_, global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption.Builder.GetReuseBuilder());
              break;
            }
          }
        }
        
        return this;
      }
      
      
      
      
      
      
      
      
    }
  }
  
  public sealed partial class EnumOptions : pb::ExtendableMessageLite {
    public EnumOptions() { }
    private static readonly string[] _enumOptionsFieldNames = new string[] { "allow_alias", "uninterpreted_option" };
    private static readonly scg::List<uint> _enumOptionsFieldTags = new scg::List<uint> { 16, 7994 };
    
    
    public const int allow_aliasFieldNumber = 2;
    private bool hasallow_alias;
    private bool allowAlias_ = true;
    public bool Hasallow_alias {
      get { return hasallow_alias; }
    }
    public bool allow_alias {
      get { return allowAlias_; }
      set { hasallow_alias = true; allowAlias_ = value;}
    }
    
    public const int uninterpreted_optionFieldNumber = 999;
    private scg::List<global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption> uninterpretedOption_ = new scg::List<global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption>();
    public scg::List<global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption> uninterpreted_option {
      get { return uninterpretedOption_; }
    }
    public int uninterpreted_optionCount {
      get { return uninterpretedOption_.Count; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption Getuninterpreted_option(int index) {
      return uninterpretedOption_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption element in uninterpreted_option) {
          if (!element.IsInitialized) return false;
        }
        if (!ExtensionsAreInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _enumOptionsFieldNames;
      pb::ExtendableMessageLite<EnumOptions, EnumOptions.Builder>.ExtensionWriter extensionWriter = CreateExtensionWriter(this);
      if (hasallow_alias) {
        output.WriteBool(2, field_names[0], allow_alias);
      }
      if (uninterpretedOption_.Count > 0) {
        output.WriteMessageArray(999, field_names[1], uninterpretedOption_);
      }
      extensionWriter.WriteUntil(536870912, output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasallow_alias) {
        size += pb::CodedOutputStream.ComputeBoolSize(2, allow_alias);
      }
      foreach (global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption element in uninterpreted_option) {
        size += pb::CodedOutputStream.ComputeMessageSize(999, element);
      }
      size += ExtensionsSerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public override void Reset(bool recursive = true, bool reuse = false)
    {
      allowAlias_ = true;
      hasallow_alias = false;
     if(recursive) for (int i = 0; i <uninterpretedOption_.Count; i++) uninterpretedOption_[i].Reset(recursive, reuse);
      uninterpretedOption_.Clear();
    看看这个是什么(536870912, output);
      memoizedSerializedSize = -1;
      base.Reset(recursive, reuse);
    }
    public static Builder CreateBuilder() { return new Builder(); }
    public override pb::IBuilderLite ToBuilder() { return CreateBuilder(this); }
    public override pb::IBuilderLite CreateBuilderForType() { if (IsReused) return Builder.GetReuseBuilder(); else return new Builder(); }
    public static Builder CreateBuilder(EnumOptions prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::ExtendableBuilderLite {
      protected override pb::IBuilderLite ThisBuilder {
        get { return this; }
      }
      public Builder() {
        resultIsReadOnly = true;
      }
      internal Builder(EnumOptions cloneFrom) {
        __result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private EnumOptions __result;
      
      private static Builder _reuseBuilder;
      
      private EnumOptions PrepareBuilder() {
        if (resultIsReadOnly) {
          __result = new EnumOptions();
          resultIsReadOnly = false;
        }
        return __result;
      }
      
      public override bool IsInitialized {
        get { return __result.IsInitialized; }
      }
      
      protected override pb::GeneratedMessageLite MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override pb::IBuilderLite Clear() {
        resultIsReadOnly = true;
        return this;
      }
      
      public override pb::IMessageLite BuildPartial() {
        if (resultIsReadOnly) {
          return __result;
        }
        resultIsReadOnly = true;
        return __result;
      }
      
      public override pb::IMessageLite BuildEmpty(){
        EnumOptions message = new EnumOptions();
        message.IsReused = IsReuseMode;
        return message;
      }
      
      public static EnumOptions.Builder GetReuseBuilder(){
        if (_reuseBuilder == null) _reuseBuilder = new Builder();
        _reuseBuilder.IsReuseMode = true;
        return _reuseBuilder;
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, null);
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input, pb::IMessageLite target) {
        if(!(target is EnumOptions)) {throw new System.Exception("Target is error Type or Null");}
        __result = target as EnumOptions;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_enumOptionsFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _enumOptionsFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, tag, field_name);
              break;
            }
            case 16: {
              __result.hasallow_alias = input.ReadBool(ref __result.allowAlias_);
              break;
            }
            case 7994: {
              if (IsReuseMode) input.ReadMessageArrayReuse(tag, field_name, __result.uninterpretedOption_, global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption.Builder.GetReuseBuilder());
              break;
            }
          }
        }
        
        return this;
      }
      
      
      
    }
  }
  
  public sealed partial class EnumValueOptions : pb::ExtendableMessageLite {
    public EnumValueOptions() { }
    private static readonly string[] _enumValueOptionsFieldNames = new string[] { "uninterpreted_option" };
    private static readonly scg::List<uint> _enumValueOptionsFieldTags = new scg::List<uint> { 7994 };
    
    
    public const int uninterpreted_optionFieldNumber = 999;
    private scg::List<global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption> uninterpretedOption_ = new scg::List<global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption>();
    public scg::List<global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption> uninterpreted_option {
      get { return uninterpretedOption_; }
    }
    public int uninterpreted_optionCount {
      get { return uninterpretedOption_.Count; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption Getuninterpreted_option(int index) {
      return uninterpretedOption_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption element in uninterpreted_option) {
          if (!element.IsInitialized) return false;
        }
        if (!ExtensionsAreInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _enumValueOptionsFieldNames;
      pb::ExtendableMessageLite<EnumValueOptions, EnumValueOptions.Builder>.ExtensionWriter extensionWriter = CreateExtensionWriter(this);
      if (uninterpretedOption_.Count > 0) {
        output.WriteMessageArray(999, field_names[0], uninterpretedOption_);
      }
      extensionWriter.WriteUntil(536870912, output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      foreach (global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption element in uninterpreted_option) {
        size += pb::CodedOutputStream.ComputeMessageSize(999, element);
      }
      size += ExtensionsSerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public override void Reset(bool recursive = true, bool reuse = false)
    {
     if(recursive) for (int i = 0; i <uninterpretedOption_.Count; i++) uninterpretedOption_[i].Reset(recursive, reuse);
      uninterpretedOption_.Clear();
    看看这个是什么(536870912, output);
      memoizedSerializedSize = -1;
      base.Reset(recursive, reuse);
    }
    public static Builder CreateBuilder() { return new Builder(); }
    public override pb::IBuilderLite ToBuilder() { return CreateBuilder(this); }
    public override pb::IBuilderLite CreateBuilderForType() { if (IsReused) return Builder.GetReuseBuilder(); else return new Builder(); }
    public static Builder CreateBuilder(EnumValueOptions prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::ExtendableBuilderLite {
      protected override pb::IBuilderLite ThisBuilder {
        get { return this; }
      }
      public Builder() {
        resultIsReadOnly = true;
      }
      internal Builder(EnumValueOptions cloneFrom) {
        __result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private EnumValueOptions __result;
      
      private static Builder _reuseBuilder;
      
      private EnumValueOptions PrepareBuilder() {
        if (resultIsReadOnly) {
          __result = new EnumValueOptions();
          resultIsReadOnly = false;
        }
        return __result;
      }
      
      public override bool IsInitialized {
        get { return __result.IsInitialized; }
      }
      
      protected override pb::GeneratedMessageLite MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override pb::IBuilderLite Clear() {
        resultIsReadOnly = true;
        return this;
      }
      
      public override pb::IMessageLite BuildPartial() {
        if (resultIsReadOnly) {
          return __result;
        }
        resultIsReadOnly = true;
        return __result;
      }
      
      public override pb::IMessageLite BuildEmpty(){
        EnumValueOptions message = new EnumValueOptions();
        message.IsReused = IsReuseMode;
        return message;
      }
      
      public static EnumValueOptions.Builder GetReuseBuilder(){
        if (_reuseBuilder == null) _reuseBuilder = new Builder();
        _reuseBuilder.IsReuseMode = true;
        return _reuseBuilder;
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, null);
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input, pb::IMessageLite target) {
        if(!(target is EnumValueOptions)) {throw new System.Exception("Target is error Type or Null");}
        __result = target as EnumValueOptions;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_enumValueOptionsFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _enumValueOptionsFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, tag, field_name);
              break;
            }
            case 7994: {
              if (IsReuseMode) input.ReadMessageArrayReuse(tag, field_name, __result.uninterpretedOption_, global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption.Builder.GetReuseBuilder());
              break;
            }
          }
        }
        
        return this;
      }
      
      
    }
  }
  
  public sealed partial class ServiceOptions : pb::ExtendableMessageLite {
    public ServiceOptions() { }
    private static readonly string[] _serviceOptionsFieldNames = new string[] { "uninterpreted_option" };
    private static readonly scg::List<uint> _serviceOptionsFieldTags = new scg::List<uint> { 7994 };
    
    
    public const int uninterpreted_optionFieldNumber = 999;
    private scg::List<global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption> uninterpretedOption_ = new scg::List<global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption>();
    public scg::List<global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption> uninterpreted_option {
      get { return uninterpretedOption_; }
    }
    public int uninterpreted_optionCount {
      get { return uninterpretedOption_.Count; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption Getuninterpreted_option(int index) {
      return uninterpretedOption_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption element in uninterpreted_option) {
          if (!element.IsInitialized) return false;
        }
        if (!ExtensionsAreInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _serviceOptionsFieldNames;
      pb::ExtendableMessageLite<ServiceOptions, ServiceOptions.Builder>.ExtensionWriter extensionWriter = CreateExtensionWriter(this);
      if (uninterpretedOption_.Count > 0) {
        output.WriteMessageArray(999, field_names[0], uninterpretedOption_);
      }
      extensionWriter.WriteUntil(536870912, output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      foreach (global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption element in uninterpreted_option) {
        size += pb::CodedOutputStream.ComputeMessageSize(999, element);
      }
      size += ExtensionsSerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public override void Reset(bool recursive = true, bool reuse = false)
    {
     if(recursive) for (int i = 0; i <uninterpretedOption_.Count; i++) uninterpretedOption_[i].Reset(recursive, reuse);
      uninterpretedOption_.Clear();
    看看这个是什么(536870912, output);
      memoizedSerializedSize = -1;
      base.Reset(recursive, reuse);
    }
    public static Builder CreateBuilder() { return new Builder(); }
    public override pb::IBuilderLite ToBuilder() { return CreateBuilder(this); }
    public override pb::IBuilderLite CreateBuilderForType() { if (IsReused) return Builder.GetReuseBuilder(); else return new Builder(); }
    public static Builder CreateBuilder(ServiceOptions prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::ExtendableBuilderLite {
      protected override pb::IBuilderLite ThisBuilder {
        get { return this; }
      }
      public Builder() {
        resultIsReadOnly = true;
      }
      internal Builder(ServiceOptions cloneFrom) {
        __result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ServiceOptions __result;
      
      private static Builder _reuseBuilder;
      
      private ServiceOptions PrepareBuilder() {
        if (resultIsReadOnly) {
          __result = new ServiceOptions();
          resultIsReadOnly = false;
        }
        return __result;
      }
      
      public override bool IsInitialized {
        get { return __result.IsInitialized; }
      }
      
      protected override pb::GeneratedMessageLite MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override pb::IBuilderLite Clear() {
        resultIsReadOnly = true;
        return this;
      }
      
      public override pb::IMessageLite BuildPartial() {
        if (resultIsReadOnly) {
          return __result;
        }
        resultIsReadOnly = true;
        return __result;
      }
      
      public override pb::IMessageLite BuildEmpty(){
        ServiceOptions message = new ServiceOptions();
        message.IsReused = IsReuseMode;
        return message;
      }
      
      public static ServiceOptions.Builder GetReuseBuilder(){
        if (_reuseBuilder == null) _reuseBuilder = new Builder();
        _reuseBuilder.IsReuseMode = true;
        return _reuseBuilder;
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, null);
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input, pb::IMessageLite target) {
        if(!(target is ServiceOptions)) {throw new System.Exception("Target is error Type or Null");}
        __result = target as ServiceOptions;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_serviceOptionsFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _serviceOptionsFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, tag, field_name);
              break;
            }
            case 7994: {
              if (IsReuseMode) input.ReadMessageArrayReuse(tag, field_name, __result.uninterpretedOption_, global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption.Builder.GetReuseBuilder());
              break;
            }
          }
        }
        
        return this;
      }
      
      
    }
  }
  
  public sealed partial class MethodOptions : pb::ExtendableMessageLite {
    public MethodOptions() { }
    private static readonly string[] _methodOptionsFieldNames = new string[] { "uninterpreted_option" };
    private static readonly scg::List<uint> _methodOptionsFieldTags = new scg::List<uint> { 7994 };
    
    
    public const int uninterpreted_optionFieldNumber = 999;
    private scg::List<global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption> uninterpretedOption_ = new scg::List<global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption>();
    public scg::List<global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption> uninterpreted_option {
      get { return uninterpretedOption_; }
    }
    public int uninterpreted_optionCount {
      get { return uninterpretedOption_.Count; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption Getuninterpreted_option(int index) {
      return uninterpretedOption_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption element in uninterpreted_option) {
          if (!element.IsInitialized) return false;
        }
        if (!ExtensionsAreInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _methodOptionsFieldNames;
      pb::ExtendableMessageLite<MethodOptions, MethodOptions.Builder>.ExtensionWriter extensionWriter = CreateExtensionWriter(this);
      if (uninterpretedOption_.Count > 0) {
        output.WriteMessageArray(999, field_names[0], uninterpretedOption_);
      }
      extensionWriter.WriteUntil(536870912, output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      foreach (global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption element in uninterpreted_option) {
        size += pb::CodedOutputStream.ComputeMessageSize(999, element);
      }
      size += ExtensionsSerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public override void Reset(bool recursive = true, bool reuse = false)
    {
     if(recursive) for (int i = 0; i <uninterpretedOption_.Count; i++) uninterpretedOption_[i].Reset(recursive, reuse);
      uninterpretedOption_.Clear();
    看看这个是什么(536870912, output);
      memoizedSerializedSize = -1;
      base.Reset(recursive, reuse);
    }
    public static Builder CreateBuilder() { return new Builder(); }
    public override pb::IBuilderLite ToBuilder() { return CreateBuilder(this); }
    public override pb::IBuilderLite CreateBuilderForType() { if (IsReused) return Builder.GetReuseBuilder(); else return new Builder(); }
    public static Builder CreateBuilder(MethodOptions prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::ExtendableBuilderLite {
      protected override pb::IBuilderLite ThisBuilder {
        get { return this; }
      }
      public Builder() {
        resultIsReadOnly = true;
      }
      internal Builder(MethodOptions cloneFrom) {
        __result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private MethodOptions __result;
      
      private static Builder _reuseBuilder;
      
      private MethodOptions PrepareBuilder() {
        if (resultIsReadOnly) {
          __result = new MethodOptions();
          resultIsReadOnly = false;
        }
        return __result;
      }
      
      public override bool IsInitialized {
        get { return __result.IsInitialized; }
      }
      
      protected override pb::GeneratedMessageLite MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override pb::IBuilderLite Clear() {
        resultIsReadOnly = true;
        return this;
      }
      
      public override pb::IMessageLite BuildPartial() {
        if (resultIsReadOnly) {
          return __result;
        }
        resultIsReadOnly = true;
        return __result;
      }
      
      public override pb::IMessageLite BuildEmpty(){
        MethodOptions message = new MethodOptions();
        message.IsReused = IsReuseMode;
        return message;
      }
      
      public static MethodOptions.Builder GetReuseBuilder(){
        if (_reuseBuilder == null) _reuseBuilder = new Builder();
        _reuseBuilder.IsReuseMode = true;
        return _reuseBuilder;
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, null);
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input, pb::IMessageLite target) {
        if(!(target is MethodOptions)) {throw new System.Exception("Target is error Type or Null");}
        __result = target as MethodOptions;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_methodOptionsFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _methodOptionsFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, tag, field_name);
              break;
            }
            case 7994: {
              if (IsReuseMode) input.ReadMessageArrayReuse(tag, field_name, __result.uninterpretedOption_, global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption.Builder.GetReuseBuilder());
              break;
            }
          }
        }
        
        return this;
      }
      
      
    }
  }
  
  public sealed partial class UninterpretedOption : pb::GeneratedMessageLite {
    public UninterpretedOption() { }
    private static readonly string[] _uninterpretedOptionFieldNames = new string[] { "aggregate_value", "double_value", "identifier_value", "name", "negative_int_value", "positive_int_value", "string_value" };
    private static readonly scg::List<uint> _uninterpretedOptionFieldTags = new scg::List<uint> { 66, 49, 26, 18, 40, 32, 58 };
    
    
    #region Nested types
    public static partial class Types {
      public sealed partial class NamePart : pb::GeneratedMessageLite {
        public NamePart() { }
        private static readonly string[] _namePartFieldNames = new string[] { "is_extension", "name_part" };
        private static readonly scg::List<uint> _namePartFieldTags = new scg::List<uint> { 16, 10 };
        
        
        public const int name_partFieldNumber = 1;
        private bool hasname_part;
        private string namePart_ = "";
        public bool Hasname_part {
          get { return hasname_part; }
        }
        public string name_part {
          get { return namePart_; }
          set { hasname_part = true; namePart_ = value;}
        }
        
        public const int is_extensionFieldNumber = 2;
        private bool hasis_extension;
        private bool isExtension_;
        public bool Hasis_extension {
          get { return hasis_extension; }
        }
        public bool is_extension {
          get { return isExtension_; }
          set { hasis_extension = true; isExtension_ = value;}
        }
        
        public override bool IsInitialized {
          get {
            if (!hasname_part)name_part = "";hasname_part = true;
            if (!hasis_extension)hasis_extension = true;
            return true;
          }
        }
        
        public override void WriteTo(pb::ICodedOutputStream output) {
          CalcSerializedSize();
          string[] field_names = _namePartFieldNames;
          if (hasname_part) {
            output.WriteString(1, field_names[1], name_part);
          }
          if (hasis_extension) {
            output.WriteBool(2, field_names[0], is_extension);
          }
        }
        
        private int memoizedSerializedSize = -1;
        public override int SerializedSize {
          get {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            return CalcSerializedSize();
          }
        }
        
        private int CalcSerializedSize() {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          
          size = 0;
          if (hasname_part) {
            size += pb::CodedOutputStream.ComputeStringSize(1, name_part);
          }
          if (hasis_extension) {
            size += pb::CodedOutputStream.ComputeBoolSize(2, is_extension);
          }
          memoizedSerializedSize = size;
          return size;
        }
        public override void Reset(bool recursive = true, bool reuse = false)
        {
          namePart_ = "";
          hasname_part = false;
          isExtension_ = false;
          hasis_extension = false;
          memoizedSerializedSize = -1;
          base.Reset(recursive, reuse);
        }
        public static Builder CreateBuilder() { return new Builder(); }
        public override pb::IBuilderLite ToBuilder() { return CreateBuilder(this); }
        public override pb::IBuilderLite CreateBuilderForType() { if (IsReused) return Builder.GetReuseBuilder(); else return new Builder(); }
        public static Builder CreateBuilder(NamePart prototype) {
          return new Builder(prototype);
        }
        
        public sealed partial class Builder : pb::GeneratedBuilderLite {
          protected override pb::IBuilderLite ThisBuilder {
            get { return this; }
          }
          public Builder() {
            resultIsReadOnly = true;
          }
          internal Builder(NamePart cloneFrom) {
            __result = cloneFrom;
            resultIsReadOnly = true;
          }
          
          private bool resultIsReadOnly;
          private NamePart __result;
          
          private static Builder _reuseBuilder;
          
          private NamePart PrepareBuilder() {
            if (resultIsReadOnly) {
              __result = new NamePart();
              resultIsReadOnly = false;
            }
            return __result;
          }
          
          public override bool IsInitialized {
            get { return __result.IsInitialized; }
          }
          
          protected override pb::GeneratedMessageLite MessageBeingBuilt {
            get { return PrepareBuilder(); }
          }
          
          public override pb::IBuilderLite Clear() {
            resultIsReadOnly = true;
            return this;
          }
          
          public override pb::IMessageLite BuildPartial() {
            if (resultIsReadOnly) {
              return __result;
            }
            resultIsReadOnly = true;
            return __result;
          }
          
          public override pb::IMessageLite BuildEmpty(){
            NamePart message = new NamePart();
            message.IsReused = IsReuseMode;
            return message;
          }
          
          public static NamePart.Builder GetReuseBuilder(){
            if (_reuseBuilder == null) _reuseBuilder = new Builder();
            _reuseBuilder.IsReuseMode = true;
            return _reuseBuilder;
          }
          
          public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input) {
            return MergeFrom(input, null);
          }
          
          public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input, pb::IMessageLite target) {
            if(!(target is NamePart)) {throw new System.Exception("Target is error Type or Null");}
            __result = target as NamePart;
            uint tag;
            string field_name;
            while (input.ReadTag(out tag, out field_name)) {
              if(tag == 0 && field_name != null) {
                int field_ordinal = global::System.Array.BinarySearch(_namePartFieldNames, field_name, global::System.StringComparer.Ordinal);
                if(field_ordinal >= 0)
                  tag = _namePartFieldTags[field_ordinal];
                else {
                  ParseUnknownField(input, tag, field_name);
                  continue;
                }
              }
              switch (tag) {
                case 0: {
                  throw pb::InvalidProtocolBufferException.InvalidTag();
                }
                default: {
                  if (pb::WireFormat.IsEndGroupTag(tag)) {
                    return this;
                  }
                  ParseUnknownField(input, tag, field_name);
                  break;
                }
                case 10: {
                  __result.hasname_part = input.ReadString(ref __result.namePart_);
                  break;
                }
                case 16: {
                  __result.hasis_extension = input.ReadBool(ref __result.isExtension_);
                  break;
                }
              }
            }
            
            return this;
          }
          
          
          
        }
      }
      
    }
    #endregion
    
    public const int nameFieldNumber = 2;
    private scg::List<global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption.Types.NamePart> name_ = new scg::List<global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption.Types.NamePart>();
    public scg::List<global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption.Types.NamePart> name {
      get { return name_; }
    }
    public int nameCount {
      get { return name_.Count; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption.Types.NamePart Getname(int index) {
      return name_[index];
    }
    
    public const int identifier_valueFieldNumber = 3;
    private bool hasidentifier_value;
    private string identifierValue_ = "";
    public bool Hasidentifier_value {
      get { return hasidentifier_value; }
    }
    public string identifier_value {
      get { return identifierValue_; }
      set { hasidentifier_value = true; identifierValue_ = value;}
    }
    
    public const int positive_int_valueFieldNumber = 4;
    private bool haspositive_int_value;
    private ulong positiveIntValue_;
    public bool Haspositive_int_value {
      get { return haspositive_int_value; }
    }
    [global::System.CLSCompliant(false)]
    public ulong positive_int_value {
      get { return positiveIntValue_; }
      set { haspositive_int_value = true; positiveIntValue_ = value;}
    }
    
    public const int negative_int_valueFieldNumber = 5;
    private bool hasnegative_int_value;
    private long negativeIntValue_;
    public bool Hasnegative_int_value {
      get { return hasnegative_int_value; }
    }
    public long negative_int_value {
      get { return negativeIntValue_; }
      set { hasnegative_int_value = true; negativeIntValue_ = value;}
    }
    
    public const int double_valueFieldNumber = 6;
    private bool hasdouble_value;
    private double doubleValue_;
    public bool Hasdouble_value {
      get { return hasdouble_value; }
    }
    public double double_value {
      get { return doubleValue_; }
      set { hasdouble_value = true; doubleValue_ = value;}
    }
    
    public const int string_valueFieldNumber = 7;
    private bool hasstring_value;
    private pb::ByteString stringValue_ = pb::ByteString.Empty;
    public bool Hasstring_value {
      get { return hasstring_value; }
    }
    public pb::ByteString string_value {
      get { return stringValue_; }
      set { hasstring_value = true; stringValue_ = value;}
    }
    
    public const int aggregate_valueFieldNumber = 8;
    private bool hasaggregate_value;
    private string aggregateValue_ = "";
    public bool Hasaggregate_value {
      get { return hasaggregate_value; }
    }
    public string aggregate_value {
      get { return aggregateValue_; }
      set { hasaggregate_value = true; aggregateValue_ = value;}
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption.Types.NamePart element in name) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _uninterpretedOptionFieldNames;
      if (name_.Count > 0) {
        output.WriteMessageArray(2, field_names[3], name_);
      }
      if (hasidentifier_value) {
        output.WriteString(3, field_names[2], identifier_value);
      }
      if (haspositive_int_value) {
        output.WriteUInt64(4, field_names[5], positive_int_value);
      }
      if (hasnegative_int_value) {
        output.WriteInt64(5, field_names[4], negative_int_value);
      }
      if (hasdouble_value) {
        output.WriteDouble(6, field_names[1], double_value);
      }
      if (hasstring_value) {
        output.WriteBytes(7, field_names[6], string_value);
      }
      if (hasaggregate_value) {
        output.WriteString(8, field_names[0], aggregate_value);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      foreach (global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption.Types.NamePart element in name) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, element);
      }
      if (hasidentifier_value) {
        size += pb::CodedOutputStream.ComputeStringSize(3, identifier_value);
      }
      if (haspositive_int_value) {
        size += pb::CodedOutputStream.ComputeUInt64Size(4, positive_int_value);
      }
      if (hasnegative_int_value) {
        size += pb::CodedOutputStream.ComputeInt64Size(5, negative_int_value);
      }
      if (hasdouble_value) {
        size += pb::CodedOutputStream.ComputeDoubleSize(6, double_value);
      }
      if (hasstring_value) {
        size += pb::CodedOutputStream.ComputeBytesSize(7, string_value);
      }
      if (hasaggregate_value) {
        size += pb::CodedOutputStream.ComputeStringSize(8, aggregate_value);
      }
      memoizedSerializedSize = size;
      return size;
    }
    public override void Reset(bool recursive = true, bool reuse = false)
    {
     if(recursive) for (int i = 0; i <name_.Count; i++) name_[i].Reset(recursive, reuse);
      name_.Clear();
      identifierValue_ = "";
      hasidentifier_value = false;
      positiveIntValue_ = 0UL;
      haspositive_int_value = false;
      negativeIntValue_ = 0L;
      hasnegative_int_value = false;
      doubleValue_ = 0D;
      hasdouble_value = false;
      stringValue_ = pb::ByteString.Empty;
      hasstring_value = false;
      aggregateValue_ = "";
      hasaggregate_value = false;
      memoizedSerializedSize = -1;
      base.Reset(recursive, reuse);
    }
    public static Builder CreateBuilder() { return new Builder(); }
    public override pb::IBuilderLite ToBuilder() { return CreateBuilder(this); }
    public override pb::IBuilderLite CreateBuilderForType() { if (IsReused) return Builder.GetReuseBuilder(); else return new Builder(); }
    public static Builder CreateBuilder(UninterpretedOption prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite {
      protected override pb::IBuilderLite ThisBuilder {
        get { return this; }
      }
      public Builder() {
        resultIsReadOnly = true;
      }
      internal Builder(UninterpretedOption cloneFrom) {
        __result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private UninterpretedOption __result;
      
      private static Builder _reuseBuilder;
      
      private UninterpretedOption PrepareBuilder() {
        if (resultIsReadOnly) {
          __result = new UninterpretedOption();
          resultIsReadOnly = false;
        }
        return __result;
      }
      
      public override bool IsInitialized {
        get { return __result.IsInitialized; }
      }
      
      protected override pb::GeneratedMessageLite MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override pb::IBuilderLite Clear() {
        resultIsReadOnly = true;
        return this;
      }
      
      public override pb::IMessageLite BuildPartial() {
        if (resultIsReadOnly) {
          return __result;
        }
        resultIsReadOnly = true;
        return __result;
      }
      
      public override pb::IMessageLite BuildEmpty(){
        UninterpretedOption message = new UninterpretedOption();
        message.IsReused = IsReuseMode;
        return message;
      }
      
      public static UninterpretedOption.Builder GetReuseBuilder(){
        if (_reuseBuilder == null) _reuseBuilder = new Builder();
        _reuseBuilder.IsReuseMode = true;
        return _reuseBuilder;
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, null);
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input, pb::IMessageLite target) {
        if(!(target is UninterpretedOption)) {throw new System.Exception("Target is error Type or Null");}
        __result = target as UninterpretedOption;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_uninterpretedOptionFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _uninterpretedOptionFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, tag, field_name);
              break;
            }
            case 18: {
              if (IsReuseMode) input.ReadMessageArrayReuse(tag, field_name, __result.name_, global::Google.ProtocolBuffers.DescriptorProtos.UninterpretedOption.Types.NamePart.Builder.GetReuseBuilder());
              break;
            }
            case 26: {
              __result.hasidentifier_value = input.ReadString(ref __result.identifierValue_);
              break;
            }
            case 32: {
              __result.haspositive_int_value = input.ReadUInt64(ref __result.positiveIntValue_);
              break;
            }
            case 40: {
              __result.hasnegative_int_value = input.ReadInt64(ref __result.negativeIntValue_);
              break;
            }
            case 49: {
              __result.hasdouble_value = input.ReadDouble(ref __result.doubleValue_);
              break;
            }
            case 58: {
              __result.hasstring_value = input.ReadBytes(ref __result.stringValue_);
              break;
            }
            case 66: {
              __result.hasaggregate_value = input.ReadString(ref __result.aggregateValue_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      
      
      
      
      
      
    }
  }
  
  public sealed partial class SourceCodeInfo : pb::GeneratedMessageLite {
    public SourceCodeInfo() { }
    private static readonly string[] _sourceCodeInfoFieldNames = new string[] { "location" };
    private static readonly scg::List<uint> _sourceCodeInfoFieldTags = new scg::List<uint> { 10 };
    
    
    #region Nested types
    public static partial class Types {
      public sealed partial class Location : pb::GeneratedMessageLite {
        public Location() { }
        private static readonly string[] _locationFieldNames = new string[] { "leading_comments", "path", "span", "trailing_comments" };
        private static readonly scg::List<uint> _locationFieldTags = new scg::List<uint> { 26, 10, 18, 34 };
        
        
        public const int pathFieldNumber = 1;
        private int pathMemoizedSerializedSize;
        private scg::List<int> path_ = new scg::List<int>();
        public scg::List<int> path {
          get { return path_; }
        }
        public int pathCount {
          get { return path_.Count; }
        }
        public int Getpath(int index) {
          return path_[index];
        }
        
        public const int spanFieldNumber = 2;
        private int spanMemoizedSerializedSize;
        private scg::List<int> span_ = new scg::List<int>();
        public scg::List<int> span {
          get { return span_; }
        }
        public int spanCount {
          get { return span_.Count; }
        }
        public int Getspan(int index) {
          return span_[index];
        }
        
        public const int leading_commentsFieldNumber = 3;
        private bool hasleading_comments;
        private string leadingComments_ = "";
        public bool Hasleading_comments {
          get { return hasleading_comments; }
        }
        public string leading_comments {
          get { return leadingComments_; }
          set { hasleading_comments = true; leadingComments_ = value;}
        }
        
        public const int trailing_commentsFieldNumber = 4;
        private bool hastrailing_comments;
        private string trailingComments_ = "";
        public bool Hastrailing_comments {
          get { return hastrailing_comments; }
        }
        public string trailing_comments {
          get { return trailingComments_; }
          set { hastrailing_comments = true; trailingComments_ = value;}
        }
        
        public override bool IsInitialized {
          get {
            return true;
          }
        }
        
        public override void WriteTo(pb::ICodedOutputStream output) {
          CalcSerializedSize();
          string[] field_names = _locationFieldNames;
          if (path_.Count > 0) {
            output.WritePackedInt32Array(1, field_names[1], pathMemoizedSerializedSize, path_);
          }
          if (span_.Count > 0) {
            output.WritePackedInt32Array(2, field_names[2], spanMemoizedSerializedSize, span_);
          }
          if (hasleading_comments) {
            output.WriteString(3, field_names[0], leading_comments);
          }
          if (hastrailing_comments) {
            output.WriteString(4, field_names[3], trailing_comments);
          }
        }
        
        private int memoizedSerializedSize = -1;
        public override int SerializedSize {
          get {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            return CalcSerializedSize();
          }
        }
        
        private int CalcSerializedSize() {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          
          size = 0;
          {
            int dataSize = 0;
            foreach (int element in path) {
              dataSize += pb::CodedOutputStream.ComputeInt32SizeNoTag(element);
            }
            size += dataSize;
            if (path_.Count != 0) {
              size += 1 + pb::CodedOutputStream.ComputeInt32SizeNoTag(dataSize);
            }
            pathMemoizedSerializedSize = dataSize;
          }
          {
            int dataSize = 0;
            foreach (int element in span) {
              dataSize += pb::CodedOutputStream.ComputeInt32SizeNoTag(element);
            }
            size += dataSize;
            if (span_.Count != 0) {
              size += 1 + pb::CodedOutputStream.ComputeInt32SizeNoTag(dataSize);
            }
            spanMemoizedSerializedSize = dataSize;
          }
          if (hasleading_comments) {
            size += pb::CodedOutputStream.ComputeStringSize(3, leading_comments);
          }
          if (hastrailing_comments) {
            size += pb::CodedOutputStream.ComputeStringSize(4, trailing_comments);
          }
          memoizedSerializedSize = size;
          return size;
        }
        public override void Reset(bool recursive = true, bool reuse = false)
        {
          path_.Clear();
          span_.Clear();
          leadingComments_ = "";
          hasleading_comments = false;
          trailingComments_ = "";
          hastrailing_comments = false;
          memoizedSerializedSize = -1;
          base.Reset(recursive, reuse);
        }
        public static Builder CreateBuilder() { return new Builder(); }
        public override pb::IBuilderLite ToBuilder() { return CreateBuilder(this); }
        public override pb::IBuilderLite CreateBuilderForType() { if (IsReused) return Builder.GetReuseBuilder(); else return new Builder(); }
        public static Builder CreateBuilder(Location prototype) {
          return new Builder(prototype);
        }
        
        public sealed partial class Builder : pb::GeneratedBuilderLite {
          protected override pb::IBuilderLite ThisBuilder {
            get { return this; }
          }
          public Builder() {
            resultIsReadOnly = true;
          }
          internal Builder(Location cloneFrom) {
            __result = cloneFrom;
            resultIsReadOnly = true;
          }
          
          private bool resultIsReadOnly;
          private Location __result;
          
          private static Builder _reuseBuilder;
          
          private Location PrepareBuilder() {
            if (resultIsReadOnly) {
              __result = new Location();
              resultIsReadOnly = false;
            }
            return __result;
          }
          
          public override bool IsInitialized {
            get { return __result.IsInitialized; }
          }
          
          protected override pb::GeneratedMessageLite MessageBeingBuilt {
            get { return PrepareBuilder(); }
          }
          
          public override pb::IBuilderLite Clear() {
            resultIsReadOnly = true;
            return this;
          }
          
          public override pb::IMessageLite BuildPartial() {
            if (resultIsReadOnly) {
              return __result;
            }
            resultIsReadOnly = true;
            return __result;
          }
          
          public override pb::IMessageLite BuildEmpty(){
            Location message = new Location();
            message.IsReused = IsReuseMode;
            return message;
          }
          
          public static Location.Builder GetReuseBuilder(){
            if (_reuseBuilder == null) _reuseBuilder = new Builder();
            _reuseBuilder.IsReuseMode = true;
            return _reuseBuilder;
          }
          
          public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input) {
            return MergeFrom(input, null);
          }
          
          public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input, pb::IMessageLite target) {
            if(!(target is Location)) {throw new System.Exception("Target is error Type or Null");}
            __result = target as Location;
            uint tag;
            string field_name;
            while (input.ReadTag(out tag, out field_name)) {
              if(tag == 0 && field_name != null) {
                int field_ordinal = global::System.Array.BinarySearch(_locationFieldNames, field_name, global::System.StringComparer.Ordinal);
                if(field_ordinal >= 0)
                  tag = _locationFieldTags[field_ordinal];
                else {
                  ParseUnknownField(input, tag, field_name);
                  continue;
                }
              }
              switch (tag) {
                case 0: {
                  throw pb::InvalidProtocolBufferException.InvalidTag();
                }
                default: {
                  if (pb::WireFormat.IsEndGroupTag(tag)) {
                    return this;
                  }
                  ParseUnknownField(input, tag, field_name);
                  break;
                }
                case 10:
                case 8: {
                  input.ReadInt32Array(tag, field_name, __result.path_);
                  break;
                }
                case 18:
                case 16: {
                  input.ReadInt32Array(tag, field_name, __result.span_);
                  break;
                }
                case 26: {
                  __result.hasleading_comments = input.ReadString(ref __result.leadingComments_);
                  break;
                }
                case 34: {
                  __result.hastrailing_comments = input.ReadString(ref __result.trailingComments_);
                  break;
                }
              }
            }
            
            return this;
          }
          
          
          
          
          
        }
      }
      
    }
    #endregion
    
    public const int locationFieldNumber = 1;
    private scg::List<global::Google.ProtocolBuffers.DescriptorProtos.SourceCodeInfo.Types.Location> location_ = new scg::List<global::Google.ProtocolBuffers.DescriptorProtos.SourceCodeInfo.Types.Location>();
    public scg::List<global::Google.ProtocolBuffers.DescriptorProtos.SourceCodeInfo.Types.Location> location {
      get { return location_; }
    }
    public int locationCount {
      get { return location_.Count; }
    }
    public global::Google.ProtocolBuffers.DescriptorProtos.SourceCodeInfo.Types.Location Getlocation(int index) {
      return location_[index];
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _sourceCodeInfoFieldNames;
      if (location_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], location_);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      foreach (global::Google.ProtocolBuffers.DescriptorProtos.SourceCodeInfo.Types.Location element in location) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, element);
      }
      memoizedSerializedSize = size;
      return size;
    }
    public override void Reset(bool recursive = true, bool reuse = false)
    {
     if(recursive) for (int i = 0; i <location_.Count; i++) location_[i].Reset(recursive, reuse);
      location_.Clear();
      memoizedSerializedSize = -1;
      base.Reset(recursive, reuse);
    }
    public static Builder CreateBuilder() { return new Builder(); }
    public override pb::IBuilderLite ToBuilder() { return CreateBuilder(this); }
    public override pb::IBuilderLite CreateBuilderForType() { if (IsReused) return Builder.GetReuseBuilder(); else return new Builder(); }
    public static Builder CreateBuilder(SourceCodeInfo prototype) {
      return new Builder(prototype);
    }
    
    public sealed partial class Builder : pb::GeneratedBuilderLite {
      protected override pb::IBuilderLite ThisBuilder {
        get { return this; }
      }
      public Builder() {
        resultIsReadOnly = true;
      }
      internal Builder(SourceCodeInfo cloneFrom) {
        __result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private SourceCodeInfo __result;
      
      private static Builder _reuseBuilder;
      
      private SourceCodeInfo PrepareBuilder() {
        if (resultIsReadOnly) {
          __result = new SourceCodeInfo();
          resultIsReadOnly = false;
        }
        return __result;
      }
      
      public override bool IsInitialized {
        get { return __result.IsInitialized; }
      }
      
      protected override pb::GeneratedMessageLite MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override pb::IBuilderLite Clear() {
        resultIsReadOnly = true;
        return this;
      }
      
      public override pb::IMessageLite BuildPartial() {
        if (resultIsReadOnly) {
          return __result;
        }
        resultIsReadOnly = true;
        return __result;
      }
      
      public override pb::IMessageLite BuildEmpty(){
        SourceCodeInfo message = new SourceCodeInfo();
        message.IsReused = IsReuseMode;
        return message;
      }
      
      public static SourceCodeInfo.Builder GetReuseBuilder(){
        if (_reuseBuilder == null) _reuseBuilder = new Builder();
        _reuseBuilder.IsReuseMode = true;
        return _reuseBuilder;
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, null);
      }
      
      public override pb::IBuilderLite MergeFrom(pb::ICodedInputStream input, pb::IMessageLite target) {
        if(!(target is SourceCodeInfo)) {throw new System.Exception("Target is error Type or Null");}
        __result = target as SourceCodeInfo;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_sourceCodeInfoFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _sourceCodeInfoFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, tag, field_name);
              break;
            }
            case 10: {
              if (IsReuseMode) input.ReadMessageArrayReuse(tag, field_name, __result.location_, global::Google.ProtocolBuffers.DescriptorProtos.SourceCodeInfo.Types.Location.Builder.GetReuseBuilder());
              break;
            }
          }
        }
        
        return this;
      }
      
      
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
